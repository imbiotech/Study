# 10162 번
# 문제
# 3개의 시간조절용 버튼 A B C가 달린 전자레인지가 있다.
# 각 버튼마다 일정한 시간이 지정되어 있어
# 해당 버튼을 한번 누를 때마다 그 시간이 동작시간에 더해진다.
# 버튼 A, B, C에 지정된 시간은 각각 5분, 1분, 10초이다.
# 냉동음식마다 전자레인지로 요리해야할 시간 T가 초단위로 표시되어 있다.
# 우리는 A, B, C 3개의 버튼을 적절히 눌러서
# 그 시간의 합이 정확히 T초가 되도록 해야 한다.
# 단 버튼 A, B, C를 누른 횟수의 합은 항상 최소가 되어야 한다.
# 이것을 최소버튼 조작이라고 한다.
# 만일 요리시간이 100초라고 하면(T=100) B를 1번, C는 4번 누르면 된다.
# 이와 다르게 C를 10번 눌러도 100초가 되지만
# 이 경우 10번은 최소 횟수가 아니기 때문이 답이 될 수 없다.
# 이 경우 B 1번, C 4번, 총 5번이 최소버튼 조작이다.
# 그리고 T=234와 같이 3개의 버튼으로 시간을 정확히 맞출 수 없는 경우도 있다.
# 여러분은 주어진 요리시간 T초를 맞추기 위한
# 최소버튼 조작 방법을 구하는 프로그램을 작성해야 한다.
# 입력
# 첫 번째 줄에는 요리시간 T(초)가 정수로 주어져 있으며
# 그 범위는 1 ≤ T ≤ 10,000 이다.
# 출력
# 여러분은 T초를 위한 최소버튼 조작의 A B C 횟수를 첫 줄에 차례대로 출력해야 한다.
# 각각의 횟수 사이에는 빈 칸을 둔다.
# 해당 버튼을 누르지 않는 경우에는 숫자 0을 출력해야한다.
# 만일 제시된 3개의 버튼으로 T초를 맞출 수 없으면 음수 -1을 첫 줄에 출력해야 한다.

A, B, C = 300, 60, 10
btn = []
btn_cnt = []
T = int(input())
if T%C != 0:
    print(-1)
else:
    btn.append(T//A)
    btn.append((T%A)//B)
    btn.append(((T%A)%B)//C)
    print(*btn)


# 10103 번
# 문제
# 창영이와 상덕이는 게임을 하고 있다.
# 게임을 시작하는 시점에서, 두 사람의 점수는 모두 100점이다.
# 게임은 여섯 면 주사위를 사용하며, 라운드로 진행된다.
# 매 라운드마다, 각 사람은 주사위를 던진다.
# 낮은 숫자가 나온 사람은 상대편 주사위에 나온 숫자만큼 점수를 잃게 된다.
# 두 사람의 주사위가 같은 숫자가 나온 경우에는 아무도 점수를 잃지 않는다.
# 게임이 끝난 이후에 두 사람의 점수를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 라운드의 수 n (1 ≤ n ≤ 15)가 주어진다.
# 다음 n개 줄에는 두 정수가 주어진다.
# 첫 번째 정수는 그 라운드에서 창영이의 주사위에 나타난 숫자,
# 두 번째 정수는 상덕이의 주사위에 나타난 숫자이다.
# 두 정수는 항상 1보다 크거나 같고, 6보다 작거나 같다.
# 출력
# 첫째 줄에 게임이 끝난 이후에 창영이의 점수, 둘째 줄에는 상덕이의 점수를 출력한다.

C, S = 100, 100
for _ in range(int(input())):
    c, s = map(int,input().split())
    if c>s:
        S-=c
    elif c<s:
        C-=s
print(f"{C}\n{S}")


# 10214 번
# 문제
# 경근이는 수업 과제의 일환으로 연세대학교의 역사를 조사하고 있었다.
# 케케묵은 도서관 구석에서 경근이가 발견한 것은 역대 연고전의 야구경기 실황 기록문서였다.
# 하지만 문서를 가지고 있음에도 불구하고
# 한 눈에 당시의 경기 승패를 파악하기에는 어려움이 많았는데,
# 문서에는 회차별 양 팀 획득 점수만이 적혀져 있기 때문이었다.
# 경근이는 주어진 방대한 자료를 해석하는것이 귀찮았기 때문에
# 절친한 프로그래머 친구인 당신에게 도움을 요청했다.
# 주어진 실황 기록문서에서 어떤 팀이 이겼는지를 알아내 경근이를 도와주자!
# 입력
# 입력 파일의 첫 번째 줄에 테스트 케이스의 수를 의미하는 자연수 T가 주어진다.
# 그 다음에는 T개의 테스트 케이스가 주어진다.
# 각 테스트 케이스는 9줄에 걸쳐서 입력되며,
# 매 줄마다 해당 회의 연세대 득점 Y와 고려대 득점 K가 공백으로 구분되어 주어진다.
# 이 두 수는 0이상 9이하이다.
# 출력
# 각각의 케이스마다 한 줄에 연세대가 이겼을 경우 "Yonsei",
# 고려대가 이겼을 경우 "Korea",
# 비겼을 경우 "Draw"를 출력한다.

for _ in range(int(input())):
    Y = []
    K = []
    for __ in range(9):
        y, k = map(int,input().split())
        Y.append(y)
        K.append(k)
    Ys = sum(Y)
    Ks = sum(K)
    if Ys>Ks:
        print("Yonsei")
    elif Ys<Ks:
        print("Korea")
    else:
        print("Draw")


# 11557 번
# 문제
# 입학 OT때 누구보다도 남다르게 놀았던 당신은
# 자연스럽게 1학년 과대를 역임하게 되었다.
# 타교와의 조인트 엠티를 기획하려는 당신은
# 근처에 있는 학교 중 어느 학교가 술을 가장 많이 먹는지 궁금해졌다.
# 학교별로 한 해동안 술 소비량이 주어질 때,
# 가장 술 소비가 많은 학교 이름을 출력하여라.
# 입력
# 입력의 첫 줄에는 테스트 케이스의 숫자 T가 주어진다.
# 매 입력의 첫 줄에는 학교의 숫자 정수 N(1 ≤ N ≤ 100)이 주어진다.
# 이어서 N줄에 걸쳐 학교 이름 S(1 ≤ |S| ≤ 20, S는 공백없는 대소문자 알파벳 문자열)와
# 해당 학교가 지난 한 해동안 소비한 술의 양 L(0 ≤ L ≤ 10,000,000)이 공백으로 구분되어 정수로 주어진다.
# 같은 테스트 케이스 안에서 소비한 술의 양이 같은 학교는 없다고 가정한다.
# 출력
# 각 테스트 케이스마다 한 줄에 걸쳐 술 소비가 가장 많은 학교의 이름을 출력한다.

# List형을 쓰는 법
for _ in range(int(input())):
    Univ = []
    Alcohol = []
    for __ in range(int(input())):
        u, a = map(str,input().split())
        Univ.append(u)
        Alcohol.append(int(a))
    print(Univ[Alcohol.index(max(Alcohol))])

# Dict형을 쓰는 법
T=int(input())
for _ in range(T):
    A={}
    for _ in range(int(input())):
        a,b=input().split()
        A[a]=int(b)
    print(max(A, key=A.get))


# 1977 번
# 문제
# M과 N이 주어질 때 M이상 N이하의 자연수 중 완전제곱수인 것을 모두 골라 그 합을 구하고 그 중 최솟값을 찾는 프로그램을 작성하시오.
# 예를 들어 M=60, N=100인 경우 60이상 100이하의 자연수 중
# 완전제곱수는 64, 81, 100 이렇게 총 3개가 있으므로 그 합은 245가 되고 이 중 최솟값은 64가 된다.
# 입력
# 첫째 줄에 M이, 둘째 줄에 N이 주어진다.
# M과 N은 10000이하의 자연수이며 M은 N보다 같거나 작다.
# 출력
# M이상 N이하의 자연수 중 완전제곱수인 것을 모두 찾아 첫째 줄에 그 합을, 둘째 줄에 그 중 최솟값을 출력한다.
# 단, M이상 N이하의 자연수 중 완전제곱수가 없을 경우는 첫째 줄에 -1을 출력한다.

M = int(input())
N = int(input())
perf = []
for i in range(M, N+1):
    if i**0.5 == int(i**0.5):
        perf.append(i)
if len(perf) == 0:
    print(-1)
else:
    print(f"{sum(perf)}\n{min(perf)}")


# 11098 번
# 문제
# 구단이 성적을 내지 못한다면 답은 새 선수 영입뿐이다.
# 이것은 오늘날 유럽 리그에서 가장 흔한 전략이고,
# 노르웨이의 로젠버그 팀은 이러한 전략이 성공한 대표적 예시다.
# 그들은 많은 스카우터들을 지구 곳곳에 파견해 가능성 있는 루키를 찾는다.
# 현재 첼시는 프리미어 리그에서 헤매고 있고, 결국 새로운 선수를 사기로 결정했다.
# 하지만 그들은 스카우터를 기다리기 지쳤고, 훨씬 더 효율적인 전략을 개발해냈다.
# "만약 무언가 팔리고 있다면, 그것에는 합당한 이유가 있다"는 배룸의 명언이 바로 그것이다.
# 축구에서 이 말은 곧 가장 비싼 선수가 가장 좋은 선수라는 이야기가 된다.
# 이에 따라 새로운 선수를 찾는 방법은 단순히 구단들에게 전화를 걸어 그들의 가장 비싼 선수를 사는게 되었다.
# 당신의 임무는 첼시가 리스트에서 가장 비싼 선수를 찾아낼 수 있도록 돕는 것이다.
# 입력
# 첫 번째 줄에는 테스트 케이스의 개수 n이 주어진다 (n≤100).
# 각 테스트 케이스의 첫 번째 줄 p는 고려해야될 선수의 수이다 (1≤p≤100).
# 그 아래 p개의 줄에는 선수의 정보가 표시된다.
# 각각의 줄은 선수의 가격 C 와 이름을 입력한다 (C<2*109).
# 모든 선수의 가격은 서로 다르다.
# 선수의 이름은 20자 이하여야 하며, 사이에 공백이 있어서는 안 된다.
# 출력
# 각각의 테스트 케이스에서 가장 비싼 선수의 이름을 출력해야한다.

for _ in range(int(input())):
    players = {}
    for __ in range(int(input())):
        salary, name = map(str,input().split())
        players[name] = int(salary)
    print(max(players, key=players.get))


# 5635 번
# 문제
# 어떤 반에 있는 학생들의 생일이 주어졌을 때,
# 가장 나이가 적은 사람과 가장 많은 사람을 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 반에 있는 학생의 수 n이 주어진다. (1 ≤ n ≤ 100)
# 다음 n개 줄에는 각 학생의 이름과 생일이 "이름 dd mm yyyy"와 같은 형식으로 주어진다.
# 이름은 그 학생의 이름이며, 최대 15글자로 이루어져 있다.
# dd mm yyyy는 생일 일, 월, 연도이다. (1990 ≤ yyyy ≤ 2010, 1 ≤ mm ≤ 12, 1 ≤ dd ≤ 31)
# 주어지는 생일은 올바른 날짜이며, 연, 월 일은 0으로 시작하지 않는다.
# 이름이 같거나, 생일이 같은 사람은 없다.
# 출력
# 첫째 줄에 가장 나이가 적은 사람의 이름, 둘째 줄에 가장 나이가 많은 사람 이름을 출력한다.

# 풀이 1; 코드 정리 전
n, d, m, y = [],[],[],[]
for _ in range(int(input())):
    N, D, M, Y = map(str,input().split())
    n.append(N);d.append(int(D));m.append(int(M));y.append(int(Y))
# d = [1, 30, 15, 18, 20]
# m = [10, 12, 8, 9, 9]
# n = ['M', 'A', 'T', 'J', 'G']
# y = [1991, 1990, 1993, 1990, 1990]
if y.count(max(y)) == 1:
    print(n[y.index(max(y))])
else:
    m2 = list(map(lambda x,z: x if z == max(y) else False, m, y))
    max_m2 = max(x for x in m2 if x is not False)
    if m2.count(max_m2) == 1:
        print(n[m2.index(max_m2)])
    else:
        d2 = list(map(lambda x,z: x if z == max(y) else False, d, y))
        max_d2 = max(x for x in d2 if x is not False)
        print(n[d2.index(max_d2)])

if y.count(min(y)) == 1:
    print(n[y.index(min(y))])
else:
    m2 = list(map(lambda x,z: x if z == min(y) else False, m, y))
    min_m2 = min(x for x in m2 if x is not False)
    if m2.count(min_m2) == 1:
        print(n[m2.index(min_m2)])
    else:
        d2 = list(map(lambda x,z: x if z == min(y) else False, d, y))
        min_d2 = min(x for x in d2 if x is not False)
        print(n[d2.index(min_d2)])

# 풀이 2; 코드 정리
def min_(a,b):
    min2 = list(map(lambda x,y: x if y == min(b) else False, a,b))
    min_min2 = min(x for x in min2 if x is not False)
    c = min2.count(min_min2)
    i = min2.index(min_min2)
    return c, i

def max_(a,b):
    max2 = list(map(lambda x, y: x if y == max(b) else False, a, b))
    max_max2 = max(x for x in max2 if x is not False)
    c = max2.count(max_max2)
    i = max2.index(max_max2)
    return c, i

n, d, m, y = [],[],[],[]
for _ in range(int(input())):
    N, D, M, Y = map(str,input().split())
    n.append(N);d.append(int(D));m.append(int(M));y.append(int(Y))
if y.count(max(y)) == 1:
    print(n[y.index(max(y))])
else:
    c, i = max_(m,y)
    if c == 1:
        print(n[i])
    else:
        c,i = max_(d,y)
        print(n[i])

if y.count(min(y)) == 1:
    print(n[y.index(min(y))])
else:
    c, i = min_(m,y)
    if c == 1:
        print(n[i])
    else:
        c, i = min_(d,y)
        print(n[i])


# 1408 번
# 문제
# 도현이는 Counter Terror Unit (CTU)에서 일하는 특수요원이다.
# 도현이는 모든 사건을 정확하게 24시간이 되는 순간 해결하는 것으로 유명하다.
# 도현이는 1시간 만에 범인을 잡을 수 있어도 잡지 않는다.
# 정확하게 24시간이 되는 순간이 아니면 잡지 않는 CTU 특수요원이다.
# 2008년 3월 3일 월요일, CTU는 새학기에 맞춰 핵폭탄을 날리겠다는 테러 정보를 입수했다.
# CTU에서는 특수요원 도현이에게 이 임무를 맡겼다.
# CTU의 프로그래머 준규는 이 사건의 배후가 김선영이란 것을 해킹을 통해 밝혀내었다.
# 도현이는 선영이를 임무를 시작한지 정확하게 24시간이 되는 순간에 잡으려고 한다.
# 만약 지금 시간이 13:52:30이고,
# 임무를 시작한 시간이 14:00:00 이라면 도현이에게 남은시간은 00:07:30 이다.
# 모든 시간은 00:00:00 ~ 23:59:59로 표현할 수 있다.
# 입력과 출력에 주어지는 모든 시간은 XX:XX:XX 형태이며,
# 숫자가 2자리가 아닐 경우에는 0으로 채운다.
# 도현이가 임무를 시작한 시간과, 현재 시간이 주어졌을 때,
# 도현이에게 남은 시간을 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에는 현재 시간이, 둘째 줄에는 도현이가 임무를 시작한 시간이 주어진다.
# 임무를 시작한 시간과 현재 시간이 같은 경우는 주어지지 않는다.
# 출력
# 첫째 줄에 도현이가 임무를 수행하는데 남은 시간을 문제에서 주어지는 시간의 형태 (XX:XX:XX)에 맞춰 출력한다.

from datetime import *
now = input().split(":")
start = input().split(":")
# now = "13:52:30".split(":")
# start = "14:00:00".split(":")
if now > start:
    now_t = datetime.combine(date(1,1,1),time(int(now[0]),int(now[1]),int(now[2])))
else:
    now_t = datetime.combine(date(1,1,2), time(int(now[0]),int(now[1]),int(now[2])))
end =  datetime.combine(date(1,1,2),time(int(start[0]),int(start[1]),int(start[2])))
left = str(end-now_t)
if len(left) == 7:
    print("0"+left)
else:
    print(left)


# 5565 번
# 문제
# 새 학기를 맞아 상근이는 책을 10권 구입했다.
# 상근이는 의욕이 너무 앞서서 가격을 조사하지 않고 책을 구입했다.
# 이제 각 책의 가격을 알아보려고 한다.
# 하지만, 영수증에는 얼룩이 묻어있었고, 상근이는 책 10권 중 9권의 가격만 읽을 수 있었다.
# 책 10권의 총 가격과 가격을 읽을 수 있는 9권 가격이 주어졌을 때,
# 가격을 읽을 수 없는 책의 가격을 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 10권의 총 가격이 주어진다.
# 둘째 줄부터 9개 줄에는 가격을 읽을 수 있는 책 9권의 가격이 주어진다.
# 책의 가격은 10,000이하인 양의 정수이다.
# 출력
# 첫째 줄에 가격을 읽을 수 없는 책의 가격을 출력한다.

books=[]
for _ in range(10):
    books.append(int(input()))
print(books[0]-sum(books[1:]))


# 2609 번
# 문제
# 두 개의 자연수를 입력받아 최대 공약수와 최소 공배수를 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에는 두 개의 자연수가 주어진다. 이 둘은 10,000이하의 자연수이며 사이에 한 칸의 공백이 주어진다.
# 출력
# 첫째 줄에는 입력으로 주어진 두 수의 최대공약수를, 둘째 줄에는 입력으로 주어진 두 수의 최소 공배수를 출력한다.

def diviser(num):
    divs = []
    for i in range(1,num+1):
        if num%i==0:
            divs.append(i)
    return divs

a, b = map(int,input().split())
dis_a = diviser(a)
dis_b = diviser(b)
max_div = max([x for x in dis_a if x in dis_b])
min_mul = int(a * b / max_div)
print(f"{max_div}\n{min_mul}")


# 10984 번
# 문제
# 게으른 근우는 열심히 놀다가 문득, 자신의 학점 평균이 얼마일지 궁금해졌다.
# 학사시스템도 들어가기 귀찮아하는 근우를 위해 구해주도록 하자.
# 입력
# 첫 번째 줄에 학기의 수 T가 주어진다.
# 두 번째 줄부터 T개 학기에 대한 정보가 주어진다.
# 각 학기에 대한 정보는 다음과 같이 구성되어 있다.
# 첫 번째 줄에 들었던 과목의 수 N이 주어지고,
# 다음 N개 줄에 걸쳐서 N개 과목들의 학점 C와 성적 G가 주어진다. (1 ≤ N ≤ 10, 1 ≤ C ≤ 6, C는 정수)
# G는 {0, 0.7, 1, 1.3, 1.7, 2, 2.3, 2.7, 3, 3.3, 3.7, 4, 4.3} 중 하나이며 소수 부분은 최대 한 자리까지 주어진다.
# 출력
# 각 학기에 대해 근우의 총 학점과 평점(GPA)을 출력한다. 정답과의 절대 오차는 10-1까지 허용한다.

for _ in range(int(input())):
    Credit = 0
    Grade = 0
    for __ in range(int(input())):
        c, g = map(float,input().split())
        Credit += c
        Grade += c*g
    print(f"{int(Credit)} {round(Grade/Credit,1)}")


# 10833 번
# 문제
# 경상북도 특산품인 사과를 학생들에게 나눠주기 위해 여러 학교에 사과를 배정하였다.
# 배정된 사과 개수는 학교마다 다를 수 있고, 학생 수도 학교마다 다를 수 있다.
# 각 학교에서는 배정된 사과를 모든 학생들에게 똑같이 나눠주되, 남는 사과의 개수를 최소로 하려고 한다.
# (서로 다른 학교에 속한 학생이 받는 사과 개수는 다를 수 있다.)
# 예를 들어, 5개 학교의 학생 수와 배정된 사과 수가 다음과 같다고 하자.
# 학교	    A	B	C	D	E
# 학생 수	24	13	5	23	7
# 사과 개수	52	22	53	10	70
# A 학교에서는 모든 학생에게 사과를 두 개씩 나눠주고 4개의 사과가 남게 된다.
# B 학교에서는 모든 학생에게 사과를 한 개씩 나눠주고 9개의 사과가 남게 된다.
# 비슷하게 C 학교에서는 3개의 사과가, D 학교에서는 10개의 사과가, E 학교에서는 0개의 사과가 남게 되어,
# 남는 사과의 총 수는 4+9+3+10+0 = 26이다.
# 각 학교의 학생 수와 사과 개수가 주어졌을 때,
# 학생들에게 나눠주고 남는 사과의 총 개수를 구하는 프로그램을 작성하시오.
# 입력
# 첫 번째 줄에는 학교의 수를 나타내는 정수 N (1 ≤ N ≤ 100)이 주어진다.
# 다음 N 개의 줄에 각 학교의 학생 수와 배정된 사과 개수를 나타내는 두 개의 정수가 주어진다.
# 학생 수와 사과 개수는 모두 1이상 100이하이다.
# 출력
# 남은 사과의 총 개수를 나타내는 정수를 출력한다.

T = 0
for _ in range(int(input())):
    S, A = map(int,input().split())
    T += A - A//S * S
print(int(T))


# 2522 번
# 문제
# 예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
# 입력
# 첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
# 출력
# 첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다.
# 예제 입력 3
# 예제 출력
#   *
#  **
# ***
#  **
#   *

N = int(input())
for i in range(1,2*N):
    print(f"""{" "*(abs(N-i))}{"*"*(N-abs(N-i))}""")


# 2523 번
# 문제
# 예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
# 입력
# 첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
# 출력
# 첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다.
# 예제 입력 3
# 예제 출력
# *
# **
# ***
# **
# *

N = int(input())
for i in range(1,2*N):
    print(f"""{"*"*(N-abs(N-i))}""")


# 9325 번
# 문제
# 해빈이는 학교를 다니면서 틈틈히 번 돈으로 자동차를 사려고 한다.
# 자동차에 여러 가지 옵션을 포함시킬 수 있는데
# 해빈이는 덧셈과 곱셈을 하지 못하기 때문에 친구 태완이에게 도움을 청했다.
# 하지만 태완이도 덧셈과 곱셈을 못한다.
# 불쌍한 이 두 친구를 위해 모든 옵션이 주어진 자동차를 구매하는데 필요한 액수를 계산해 주자.
# 입력
# 첫째 줄에 테스트 케이스의 개수가 주어진다.
# 각 테스트 케이스의 첫 줄엔 자동차의 가격 s가 주어진다. (1 ≤ s ≤ 100 000)
# 둘째 줄엔 해빈이가 구매하려고 하는 서로 다른 옵션의 개수 n이 주어진다. (0 ≤ n ≤ 1 000)
# 뒤이어 n개의 줄이 입력으로 들어온다.
# 각 줄은 q 와 p로 이루어져 있는데
# q는 해빈이가 사려고 하는 특정 옵션의 개수이고
# p는 해당 옵션의 가격이다. (1 ≤ q ≤ 100, 1 ≤ p ≤ 10 000)
# 출력
# 각 테스트 케이스 마다, 해빈이가 최종적으로 구매하려는 자동차의 가격을 한줄씩 출력한다.

from sys import *
input = stdin.readline # 안 넣고 2248ms / 넣고 116ms
for _ in range(int(input())):
    s=int(input())
    for __ in range(int(input())):
        q, p =map(int,input().split())
        s+=q*p
    print(s)


# 2445 번
# 문제
# 예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
# 입력
# 첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
# 출력
# 첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다.
# 예제 입력 5
# 예제 출력
# *        *
# **      **
# ***    ***
# ****  ****
# **********
# ****  ****
# ***    ***
# **      **
# *        *

N = int(input())
for i in range(1,2*N):
    j = abs(N-i)
    print(f"""{"*"*(N-j)}{" "*2*j}{"*"*(N-j)}""")


# 2446 번
# 문제
# 예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
# 입력
# 첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
# 출력
# 첫째 줄부터 2×N-1번째 줄까지 차례대로 별을 출력한다.
# 예제 입력 5
# 예제 출력
# *********
#  *******
#   *****
#    ***
#     *
#    ***
#   *****
#  *******
# *********

N = int(input())
for i in range(1,2*N):
    j = abs(N-i)
    print(f"""{" "*(N-j-1)}{"*"*(2*j+1)} """)


# 2010 번
# 문제
# 선영이의 집에는 콘센트를 꽂을 수 있는 플러그가 하나밖에 없다.
# 선영이는 많은 컴퓨터를 가지고 있는데, 컴퓨터의 전원 문제는 어떻게 해결하는 것일까?
# 하나의 플러그가 있고, N개의 멀티탭이 있다.
# 각 멀티탭은 몇 개의 플러그로 이루어져 있다고 한다.
# 최대 몇 대의 컴퓨터를 전원에 연결할 수 있을까?
# 입력
# 첫째 줄에 멀티탭의 개수 N이 주어진다. (1 ≤ N ≤ 500,000)
# 이어서 둘째 줄부터 N개의 줄에 걸쳐
# 각 멀티탭이 몇 개의 플러그를 꽂을 수 있도록 되어 있는지를 나타내는 자연수가 주어진다.
# 이 자연수는 1,000을 넘지 않는다.
# 출력
# 첫째 줄에 최대로 전원에 연결될 수 있는 컴퓨터의 수를 출력한다.

from sys import *
input = stdin.readline # 안 넣고 시간 초과 / 넣고 272ms
c = 1
for _ in range(int(input())):
    m = int(input())
    c+=m-1
print(c)


# 5522 번
# 문제
# JOI군은 카드 게임을 하고 있다.
# 이 카드 게임은 5회의 게임으로 진행되며,
# 그 총점으로 승부를 하는 게임이다.
# JOI군의 각 게임의 득점을 나타내는 정수가 주어졌을 때,
# JOI군의 총점을 구하는 프로그램을 작성하라.
# 입력
# 표준 입력에서 다음과 같은 데이터를 읽어온다.
# i 번째 줄(1 ≤ i ≤ 5)에는 정수 Ai가 적혀있다.
# 이것은 i번째 게임에서의 JOI군의 점수를 나타낸다.
# 출력
# 표준 출력에 JOI군의 총점을 한 줄로 출력하라.
# 제한
# 0 ≤ Ai ≤ 100.

s = 0
for _ in range(5):
    s+=int(input())
print(s)


# 10178 번
# 문제
# 할로윈데이에 한신이네는 아부지가 사탕을 나눠주신다.
# 하지만 한신이의 형제들은 서로 사이가 좋지않아
# 서른이 넘어서도 사탕을 공정하게 나누어 주지 않으면 서로 싸움이 난다.
# 매년 할로윈데이때마다 아부지는 사탕을
# 자식들에게 최대한 많은 사탕을 나누어 주시기 원하며
# 자신에게는 몇개가 남게되는지에 알고 싶어 하신다.
# 이런 아부지를 도와서 형제간의 싸움을 막아보자.
# 입력
# 가장 첫 번째 줄에는 테스트 케이스의 수가 입력되고,
# 각 테스트 케이스마다 사탕의 개수 c와 형제의 수 v가 차례대로 입력된다.
# 출력
# 출력은 예제를 보고
# ”You get __ piece(s) and your dad gets __ piece(s).”
# 형식에 맞추어 적절하게 출력하라.
# 제한
# 1 ≤ c, v ≤ 1,000
# 예제 입력
# 5
# 22 3
# 15 5
# 99 8
# 7 4
# 101 5
# 예제 출력
# You get 7 piece(s) and your dad gets 1 piece(s).
# You get 3 piece(s) and your dad gets 0 piece(s).
# You get 12 piece(s) and your dad gets 3 piece(s).
# You get 1 piece(s) and your dad gets 3 piece(s).
# You get 20 piece(s) and your dad gets 1 piece(s).

for _ in range(int(input())):
    candy, sibling = map(int,input().split())
    print(f"""You get {candy//sibling} piece(s) and your dad gets {candy%sibling} piece(s).""")


# 9295 번
# 문제
# 오늘은 갑자기 주사위를 던지고 싶다.
# 그런데 코딩도 하고 싶다.
# 그럼 같이할까?
# 입력
# 첫째 줄에 테스트 케이스의 개수 T가 주어진다.
# 각 테스트 케이스는 한 줄로 이루어져 있으며,
# 주사위를 두 번 던져 나온 두 수를 입력한다.
# 출력
# 각 테스트 케이스마다 "Case x: "를 출력한 다음,
# 주사위를 두 번 던져 나온 두 수의 합을 출력한다.
# 테스트 케이스 번호(x)는 1부터 시작한다.

from sys import *
input = stdin.readline # 안 넣고 168ms / 넣고 76ms
for i in range(int(input())):
    a, b = map(int,input().split())
    print(f"Case {i+1}: {a+b}")


# 10569 번
# 문제
# 수학자가 구를 깎아서 볼록다면체를 만들었다.
# 이 수학자는 임의의 볼록다면체에 대해
# (꼭짓점의 수) - (모서리의 수) + (면의 수) = 2가 성립한다는 것을 알고 있다.
# 그래서 구를 깎는 게 취미인 이 사람은
# 꼭짓점, 모서리와 면의 수를 기록할 때 꼭짓점과 모서리의 수만 세고 면의 수는 세지 않는다.
# 입력
# 첫 번째 줄에 1 이상 100 이하의 자연수 T가 주어진다.
# 다음 T개의 줄에 4 이상 100 이하의 자연수 V와 E가 공백을 사이에 두고 주어진다.
# V와 E는 각각 꼭짓점의 개수와 모서리의 개수이다.
# 출력
# 각 V와 E에 대해 볼록다면체의 면의 수를 한 줄에 하나씩 출력한다.

from sys import *
input = stdin.readline # 안 넣고 68ms / 넣고 76ms
for i in range(int(input())):
    V, E = map(int,input().split())
    print(2+E-V)


# 2921 번
# 문제
# 도미노는 여러 종류의 타일 게임에서 사용하는 조각이다.
# 도미노 조각은 두 칸으로 이루어져 있다.
# 각 칸에는 점이 찍혀있는데, 점이 안 찍혀져 있을 수도 있다.
# 점의 개수는 세트의 크기에 의해서 결정된다.
# 세트의 크기가 N인 도미노 세트에서 점의 개수는
# 0보다 크거나 같고, N보다 작거나 같다.
# 두 도미노에 찍혀잇는 점의 개수가 같다면, 두 도미노는 동일한 것이다.
# 예를 들어, 점이 2개와 8개 찍혀있는 도미노는
# 8개와 2개 찍혀있는 도미노와 같은 도미노이다.
# 크기가 N인 도미노 세트는
# N 또는 그보다 작거나 같은 점을 포함하는 가능한 도미노를 모두 포함하고 있고,
# 각 도미노는 중복되지 않는다.
# 다음은 크기가 2인 도미노 세트이다.
# N을 입력받은 뒤, 크기가 N인 도미노 세트에는
# 점이 몇 개 찍혀 있는지 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 도미노 세트의 크기 N (1 ≤ N ≤ 1000)이 주어진다.
# 출력
# 크기가 N인 도미노 세트에 찍혀 있는 점의 개수를 출력한다.

n = int(input()) # 중복 조합 n_H_r = n+r-1_C_r
print(int((n+2)*(n+1)*n/2))


# 10995 번
# 문제
# 예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
# 입력
# 첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
# 출력
# 첫째 줄부터 차례대로 별을 출력한다.

n = int(input())
star = "*"+" *"*(n-1)
for i in range(n):
    if i%2 == 0:
        print(star)
    else:
        print(" "+star)


# 10991 번
# 문제
# 예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.
# 입력
# 첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.
# 출력
# 첫째 줄부터 차례대로 별을 출력한다.

n = int(input())
for i in range(n):
    print(" "*(n-i-1)+"*"+" *"*i)


# 2501 번
# 문제
# 어떤 자연수 p와 q가 있을 때, 만일 p를 q로 나누었을 때 나머지가 0이면 q는 p의 약수이다.
# 6을 예로 들면
# 6 ÷ 1 = 6 … 0
# 6 ÷ 2 = 3 … 0
# 6 ÷ 3 = 2 … 0
# 6 ÷ 4 = 1 … 2
# 6 ÷ 5 = 1 … 1
# 6 ÷ 6 = 1 … 0
# 그래서 6의 약수는 1, 2, 3, 6, 총 네 개이다.
# 두 개의 자연수 N과 K가 주어졌을 때, N의 약수들 중 K번째로 작은 수를 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 N과 K가 빈칸을 사이에 두고 주어진다.
# N은 1 이상 10,000 이하이다. K는 1 이상 N 이하이다.
# 출력
# 첫째 줄에 N의 약수들 중 K번째로 작은 수를 출력한다.
# 만일 N의 약수의 개수가 K개보다 적어서 K번째 약수가 존재하지 않을 경우에는 0을 출력하시오.

def diviser(num):
    divs = []
    for i in range(1,num+1):
        if num%i==0:
            divs.append(i)
    return divs

N, K = map(int,input().split())
N_divs = diviser(N)
try:
    print(N_divs[K-1])
except:
    print(0)


# 2747 번
# 문제
# 피보나치 수는 0과 1로 시작한다.
# 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다.
# 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.
# 이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.
# n=17일때 까지 피보나치 수를 써보면 다음과 같다.
# 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597
# n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 n이 주어진다. n은 45보다 작거나 같은 자연수이다.
# 출력
# 첫째 줄에 n번째 피보나치 수를 출력한다.

# 풀이 1 - 시간 초과,
from time import *
stt=time()
def fib(n):
    if n in [0,1]:
        return n
    else:
        return fib(n-1)+fib(n-2)

print(fib(int(input())))
print(time()-stt)

# 풀이 2 - 훨씬 빠름
from time import *
stt=time()
fib = [0,1,1]
n=int(input())
while True:
    try:
        print(fib[n])
        break
    except:
        fib.append(fib[-1]+fib[-2])
print(time()-stt)


# 2576 번
# 문제
# 7개의 자연수가 주어질 때, 이들 중 홀수인 자연수들을 모두 골라 그 합을 구하고,
# 고른 홀수들 중 최솟값을 찾는 프로그램을 작성하시오.
# 예를 들어, 7개의 자연수 12, 77, 38, 41, 53, 92, 85가 주어지면 이들 중 홀수는 77, 41, 53, 85이므로 그 합은
# 77 + 41 + 53 + 85 = 256
# 이 되고,
# 41 < 53 < 77 < 85
# 이므로 홀수들 중 최솟값은 41이 된다.
# 입력
# 입력의 첫째 줄부터 일곱 번째 줄까지 한 줄에 하나의 자연수가 주어진다.
# 주어지는 자연수는 100보다 작다.
# 출력
# 홀수가 존재하지 않는 경우에는 첫째 줄에 -1을 출력한다.
# 홀수가 존재하는 경우 첫째 줄에 홀수들의 합을 출력하고, 둘째 줄에 홀수들 중 최솟값을 출력한다.

nums = []
for _ in range(7):
    nums.append(int(input()))
odds = [x for x in nums if x%2==1]
if len(odds)==0:
    print(-1)
else:
    print(f"{sum(odds)}\n{min(odds)}")


# 9085 번
# 문제
# 10보다 작거나 같은 자연수 N개를 주면 합을 구하는 프로그램을 작성하시오.
# 입력
# 입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 10)가 주어진다.
# 각 테스트 케이스는 첫 줄에 자연수의 개수 N(1 ≤ N ≤ 100)이 주어지고,
# 그 다음 줄에는 N개의 자연수가 주어진다.
# 각각의 자연수 사이에는 하나씩의 공백이 있다.
# 출력
# 각 테스트 케이스에 대해서 주어진 자연수의 합을 한 줄에 하나씩 출력한다.

for _ in range(int(input())):
    int(input())
    N = list(map(int,input().split()))
    print(sum(N))


# 2490 번
# 문제
# 우리나라 고유의 윷놀이는 네 개의 윷짝을 던져서 배(0)와 등(1)이 나오는 숫자를 세어
# 도, 개, 걸, 윷, 모를 결정한다.
# 네 개 윷짝을 던져서 나온 각 윷짝의 배 혹은 등 정보가 주어질 때
# 도(배 한 개, 등 세 개), 개(배 두 개, 등 두 개),
# 걸(배 세 개, 등 한 개), 윷(배 네 개), 모(등 네 개)
# 중 어떤 것인지를 결정하는 프로그램을 작성하라.
# 입력
# 첫째 줄부터 셋째 줄까지 각 줄에
# 각각 한 번 던진 윷짝들의 상태를 나타내는 네 개의 정수(0 또는 1)가
# 빈칸을 사이에 두고 주어진다.
# 출력
# 첫째 줄부터 셋째 줄까지 한 줄에 하나씩 결과를
# 도는 A, 개는 B, 걸은 C, 윷은 D, 모는 E로 출력한다.

# 풀이 1 - 개수 확인 해서 if문으로 출력
for _ in range(3):
    n = list(map(int,input().split()))
    # 0: 배, 1: 등
    # 0 1개 1 3개: 도
    back = n.count(1) # 등이 몇 개?
    if back == 0:
        print("D")
    elif back == 4:
        print("E")
    elif back == 3:
        print("A")
    elif back == 2:
        print("B")
    else:
        print("C")

# 풀이 2 - 개수에 따른 index로 출력
for _ in range(3):
    n = list(map(int,input().split()))
    print("DCBAE"[n.count(1)])


# 10797 번
# 문제
# 서울시는 6월 1일부터 교통 혼잡을 막기 위해서 자동차 10부제를 시행한다.
# 자동차 10부제는 자동차 번호의 일의 자리 숫자와 날짜의 일의 자리 숫자가 일치하면
# 해당 자동차의 운행을 금지하는 것이다.
# 예를 들어, 자동차 번호의 일의 자리 숫자가 7이면 7일, 17일, 27일에 운행하지 못한다.
# 또한, 자동차 번호의 일의 자리 숫자가 0이면 10일, 20일, 30일에 운행하지 못한다.
# 여러분들은 일일 경찰관이 되어 10부제를 위반하는 자동차의 대수를 세는 봉사활동을 하려고 한다.
# 날짜의 일의 자리 숫자가 주어지고 5대의 자동차 번호의 일의 자리 숫자가 주어졌을 때
# 위반하는 자동차의 대수를 출력하면 된다.
# 입력
# 첫 줄에는 날짜의 일의 자리 숫자가 주어지고
# 두 번째 줄에는 5대의 자동차 번호의 일의 자리 숫자가 주어진다.
# 날짜와 자동차의 일의 자리 숫자는 모두 0에서 9까지의 정수 중 하나이다.
# 출력
# 주어진 날짜와 자동차의 일의 자리 숫자를 보고 10부제를 위반하는 차량의 대수를 출력한다.

date=input()
car=input().split()
print(car.count(date))


# 2506 번
# 문제
# OX 문제는 맞거나 틀린 두 경우의 답을 가지는 문제를 말한다.
# 여러 개의 OX 문제로 만들어진 시험에서 연속적으로 답을 맞히는 경우에는 가산점을 주기 위해서
# 다음과 같이 점수 계산을 하기로 하였다.
# 1번 문제가 맞는 경우에는 1점으로 계산한다.
# 앞의 문제에 대해서는 답을 틀리다가 답이 맞는 처음 문제는 1점으로 계산한다.
# 또한, 연속으로 문제의 답이 맞는 경우에서 두 번째 문제는 2점,
# 세 번째 문제는 3점, ..., K번째 문제는 K점으로 계산한다.
# 틀린 문제는 0점으로 계산한다.
# 예를 들어, 아래와 같이 10 개의 OX 문제에서
# 답이 맞은 문제의 경우에는 1로 표시하고,
# 틀린 경우에는 0으로 표시하였을 때,
# 점수 계산은 아래 표와 같이 계산되어, 총 점수는 1+1+2+3+1+2=10 점이다.
# 시험문제의 채점 결과가 주어졌을 때, 총 점수를 계산하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 문제의 개수 N (1 ≤ N ≤ 100)이 주어진다.
# 둘째 줄에는 N개 문제의 채점 결과를 나타내는 0 혹은 1이 빈 칸을 사이에 두고 주어진다.
# 0은 문제의 답이 틀린 경우이고, 1은 문제의 답이 맞는 경우이다.
# 출력
# 첫째 줄에 입력에서 주어진 채점 결과에 대하여 가산점을 고려한 총 점수를 출력한다.

def ss(S):
    for i in range(len(S)):
        if i==0 or S[i]==0:
            continue
        elif S[i]==1:
            S[i]+=S[i-1]
    return S

N = int(input())
S = list(map(int,input().split()))
print(sum(ss(S)))


# 2455 번
# 문제
# 최근에 개발된 지능형 기차가 1번역(출발역)부터 4번역(종착역)까지 4개의 정차역이 있는 노선에서 운행되고 있다.
# 이 기차에는 타거나 내리는 사람 수를 자동으로 인식할 수 있는 장치가 있다.
# 이 장치를 이용하여 출발역에서 종착역까지 가는 도중 기차 안에 사람이 가장 많을 때의 사람 수를 계산하려고 한다.
# 단, 이 기차를 이용하는 사람들은 질서 의식이 투철하여,
# 역에서 기차에 탈 때, 내릴 사람이 모두 내린 후에 기차에 탄다고 가정한다.
# 	        내린 사람 수	탄 사람 수
# 1번역(출발역)  	0        	32
# 2번역	        3	        13
# 3번역	        28       	25
# 4번역(종착역) 	39	        0
# 예를 들어, 위와 같은 경우를 살펴보자.
# 이 경우, 기차 안에 사람이 가장 많은 때는
# 2번역에서 3명의 사람이 기차에서 내리고, 13명의 사람이 기차에 탔을 때로,
# 총 42명의 사람이 기차 안에 있다.
# 이 기차는 다음 조건을 만족하면서 운행된다고 가정한다.
# 기차는 역 번호 순서대로 운행한다.
# 출발역에서 내린 사람 수와 종착역에서 탄 사람 수는 0이다.
# 각 역에서 현재 기차에 있는 사람보다 더 많은 사람이 내리는 경우는 없다.
# 기차의 정원은 최대 10,000명이고, 정원을 초과하여 타는 경우는 없다.
# 4개의 역에 대해 기차에서 내린 사람 수와 탄 사람 수가 주어졌을 때,
# 기차에 사람이 가장 많을 때의 사람 수를 계산하는 프로그램을 작성하시오.
# 입력
# 각 역에서 내린 사람 수와 탄 사람 수가
# 빈칸을 사이에 두고 첫째 줄부터 넷째 줄까지 역 순서대로 한 줄에 하나씩 주어진다.
# 출력
# 첫째 줄에 최대 사람 수를 출력한다.

M,P = 0,0
for _ in range(4):
    d, u = map(int,input().split())
    P-=d
    P+=u
    M = max([M,P])
print(M)


# 2460 번
# 문제
# 최근에 개발된 지능형 기차가 1번역(출발역)부터 10번역(종착역)까지
# 10개의 정차역이 있는 노선에서 운행되고 있다.
# 이 기차에는 타거나 내리는 사람 수를 자동으로 인식할 수 있는 장치가 있다.
# 이 장치를 이용하여 출발역에서 종착역까지 가는 도중 기차 안에 사람이 가장 많을 때의 사람 수를 계산하려고 한다.
# 단, 이 기차를 이용하는 사람들은 질서 의식이 투철하여, 역에서 기차에 탈 때,
# 내릴 사람이 모두 내린 후에 기차에 탄다고 가정한다.
# 	         내린 사람 수	탄 사람 수
# 1번역(출발역)	       0	   32
# 2번역	           3	   13
# 3번역	           28	   25
# 4번역	           17   	5
# 5번역             	21   	20
# 6번역	           11	   0
# 7번역	           12	   12
# 8번역	            4	   2
# 9번역	           0	   8
# 10번역(종착역)	   21	   0
# 예를 들어, 위와 같은 경우를 살펴보자.
# 이 경우, 기차 안에 사람이 가장 많은 때는
# 2번역에서 3명의 사람이 기차에서 내리고, 13명의 사람이 기차에 탔을 때로,
# 총 42명의 사람이 기차 안에 있다.
# 이 기차는 다음 조건을 만족하면서 운행된다고 가정한다.
# 기차는 역 번호 순서대로 운행한다.
# 출발역에서 내린 사람 수와 종착역에서 탄 사람 수는 0이다.
# 각 역에서 현재 기차에 있는 사람보다 더 많은 사람이 내리는 경우는 없다.
# 기차의 정원은 최대 10,000명이고, 정원을 초과하여 타는 경우는 없다.
# 10개의 역에 대해 기차에서 내린 사람 수와 탄 사람 수가 주어졌을 때,
# 기차에 사람이 가장 많을 때의 사람 수를 계산하는 프로그램을 작성하시오.
# 입력
# 각 역에서 내린 사람 수와 탄 사람 수가 빈칸을 사이에 두고
# 첫째 줄부터 열 번째 줄까지 역 순서대로 한 줄에 하나씩 주어진다.
# 출력
# 첫째 줄에 최대 사람 수를 출력한다.

M,P = 0,0
for _ in range(10):
    d, u = map(int,input().split())
    P-=d
    P+=u
    M = max([M,P])
print(M)
