# 10828 번 - 완료
# 문제
# 정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.
# 명령은 총 다섯 가지이다.
# push X: 정수 X를 스택에 넣는 연산이다.
# pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다.
# 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.
# size: 스택에 들어있는 정수의 개수를 출력한다.
# empty: 스택이 비어있으면 1, 아니면 0을 출력한다.
# top: 스택의 가장 위에 있는 정수를 출력한다.
# 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.
# 입력
# 첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다.
# 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다.
# 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다.
# 문제에 나와있지 않은 명령이 주어지는 경우는 없다.
# 출력
# 출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.

# 풀이 1
from sys import stdin
input = stdin.readline

global stk
stk = []

def func(a):
    # for _ in a:
    #   print(type(_))
    if "push" in a:
        stk.append(int(a[1]))
    elif "pop" in a:
        if len(stk) == 0:
            print(-1)
        else:
            print(stk[-1])
            return stk.pop(-1)
    elif "size" in a:
        return print(len(stk))
    elif "empty" in a:
        if len(stk) == 0:
            print(1)
        else:
            print(0)
    else:
        if len(stk) == 0:
            print(-1)
        else:
            print(stk[-1])

for _ in range(int(input())):
    func(list(map(str, input().split())))


# 2231 번 - 완료
# 문제
# 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다.
# 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다.
# 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다.
# 따라서 245는 256의 생성자가 된다.
# 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다.
# 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.
# 자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
# 출력
# 첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.

def separation(N):
  sep = [N]
  while N>=1:
    sep.append(N%10)
    N//=10
  return sum(sep)

N = int(input())
gen = [i for i in range(N-9*len(str(N)),N)]
sep = list(map(separation,gen))
if N in sep:
  print(gen[sep.index(N)])
else:
  print(0)


# 2798 번 - 완료
# 문제
# 카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다.
# 카드의 합이 21을 넘지 않는 한도 내에서,
# 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.
# 한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.
# 김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다.
# 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다.
# 그런 후에 딜러는 숫자 M을 크게 외친다.
# 이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다.
# 블랙잭 변형 게임이기 때문에,
# 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.
# N장의 카드에 써져 있는 숫자가 주어졌을 때,
# M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.
# 입력
# 첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다.
# 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.
# 합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.
# 출력
# 첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.

from sys import stdin
input = stdin.readline

N, M = map(int,input().split())
cards = list(map(int,input().split()))
bj = []

for i in cards:
  # 파이썬 list는 =으로 복사할 경우 pointer가 두 개가 될 뿐 두 개의 list가 생성되지는 않음
  cards_j = cards.copy()
  cards_j.remove(i)
  for j in cards_j:
    cards_k = cards_j.copy()
    cards_k.remove(j)
    for k in cards_k:
      if i+j+k<=M:
        bj.append(i+j+k)

print(max(bj))

# 7568 번 - 완료
# 문제
# 우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다.
# 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다.
# 두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때
# x > p 그리고 y > q 이라면 우리는 A의 덩치가 B의 덩치보다 "더 크다"고 말한다.
# 예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면
# A의 덩치가 B보다 큰 셈이 된다.
# 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다.
# 예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면
# 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로,
# "덩치"로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.
# N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 "큰 덩치"의 사람의 수로 정해진다.
# 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다.
# 이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다.
# 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.
# 이름	(몸무게, 키)	덩치 등수
# A	(55, 185)	2
# B	(58, 183)	2
# C	(88, 186)	1
# D	(60, 175)	2
# E	(46, 155)	5
# 위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다.
# 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다.
# 그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다.
# 위 경우에 3등과 4등은 존재하지 않는다.
# 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서
# 각 사람의 덩치 등수를 계산하여 출력해야 한다.
# 입력
# 첫 줄에는 전체 사람의 수 N이 주어진다.
# 그리고 이어지는 N개의 줄에는
# 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.
# 출력
# 여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다.
# 단, 각 덩치 등수는 공백문자로 분리되어야 한다.

N = int(input())
big = [0] * N
index = [i for i in range(N)]
orders = [0] * N
order = 1

for _ in range(N):
    big[_] = list(map(int, input().split()))

for i in index:
    index_j = index.copy()
    index_j.remove(i)
    for j in index_j:
        if (big[i][0] < big[j][0]) and (big[i][1] < big[j][1]):
            orders[i] += 1

orders = list(map(lambda x: x + 1, orders))

print(*orders)

# 9020 번 - 완료
# 문제
# 1보다 큰 자연수 중에서  1과 자기 자신을 제외한 약수가 없는 자연수를 소수라고 한다.
# 예를 들어, 5는 1과 5를 제외한 약수가 없기 때문에 소수이다.
# 하지만, 6은 6 = 2 × 3 이기 때문에 소수가 아니다.
# 골드바흐의 추측은 유명한 정수론의 미해결 문제로,
# 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 것이다.
# 이러한 수를 골드바흐 수라고 한다.
# 또, 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다.
# 예를 들면,
# 4 = 2 + 2, 6 = 3 + 3, 8 = 3 + 5, 10 = 5 + 5,
# 12 = 5 + 7, 14 = 3 + 11, 14 = 7 + 7이다.
# 10000보다 작거나 같은 모든 짝수 n에 대한 골드바흐 파티션은 존재한다.
# 2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오.
# 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T가 주어진다.
# 각 테스트 케이스는 한 줄로 이루어져 있고 짝수 n이 주어진다.
# 출력
# 각 테스트 케이스에 대해서 주어진 n의 골드바흐 파티션을 출력한다.
# 출력하는 소수는 작은 것부터 먼저 출력하며, 공백으로 구분한다.

from sys import stdin

input = stdin.readline


def prime(n):
    if n == 1:
        return 0
    else:
        m = int(n ** 0.5 + 1)
        for i in range(2, m):
            if n % i == 0:
                n = 0
                break
        return n


# Prime을 매 회차 진행하지 말고, 한 번 만든 다음에 더 이상 하지 않도록 설정
No = [i for i in range(10000 + 1)]
Prime = list(set(map(prime, No)))[1:]
Prime.sort()

for _ in range(int(input())):
    n = int(input())
    Goldbach = {}
    for i in Prime:
        # i 가 n/2보다 작으면 continue하고 그 이상일 경우에만 순서쌍 확인
        if i < n / 2:
            continue
        if n - i in Prime:
            Goldbach = {
                "1st": n - i,
                "2nd": i,
            }
            break
    print(Goldbach["1st"], Goldbach["2nd"])


# 1436 번
# 문제
# 666은 종말을 나타내는 숫자라고 한다.
# 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다.
# 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다.
# 조지 루카스는 스타워즈를 만들 때,
# 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고,
# 피터 잭슨은 반지의 제왕을 만들 때,
# 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다.
# 하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서
# 영화 제목을 좀 다르게 만들기로 했다.
# 종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다.
# 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다.
# 따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666,
# 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다.
# 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.
# 숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오.
# 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.
# 입력
# 첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.
# 출력
# 첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.

# 풀이 1
def six(n):
  if "666" in str(n):
    return n
  else:
    return

sixes = list(set(map(six, range(1,4000000))))
sixes.remove(None)
sixes.sort()
N=int(input())
print(sixes[N-1])


# 2751 번
# 문제
# N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
# 둘째 줄부터 N개의 줄에는 수가 주어진다.
# 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.
# 출력
# 첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

# 풀이 1
from sys import stdin
input = stdin.readline

def merge(data): # 병합 정렬
    if len(data) <= 1:
        return

    cut = len(data) // 2
    left_data = data[:cut]
    right_data = data[cut:]

    merge(left_data)
    merge(right_data)
    # rawdata = [5,4,8,9,0,1,2,3,7,6] 일때
    # 1. left = 5, right = 4 // [4, 5]
    # 2. left = 9, right = 0 // [0, 9]
    # 3. left = 8, right = 0, 9 // [0, 8, 9]
    # 4. left = 4, 5, right = 0, 8, 9 // [0, 4, 5, 8, 9]
    # 5. left = 1, right= 2 // [1, 2]
    # 6. left = 7, right =6 // [6, 7]
    # 7. left = 3, right = 6, 7 // [3, 6, 7]
    # 8. left = 1, 2, right = 3, 6, 7 // [1, 2, 3, 6, 7]
    # 9. left= 0, 4, 5, 8, 9, right = 1, 2, 3, 6, 7 // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    left = 0
    right = 0
    now = 0

    # 어느 한 쪽이 빈 데이터면 건너 뜀
    while left < len(left_data) and right < len(right_data):
        # 양 쪽 데이터 모두 빈 데이터가 아닐 때

        # left_data의 첫 번째 원소와 right_data의 첫 번째 원소를 비교
        if left_data[left] < right_data[right]:
            # right가 클 경우에
            # 원본 리스트의 첫 번째 자리에 left를 집어넣고 인덱스를 하나씩 이동
            data[now] = left_data[left]
            left += 1
            now += 1
        else:
            # left가 클 경우에
            # 원본 리스트의 첫 번째 자리에 right를 집어넣고 인덱스를 하나씩 이동
            data[now] = right_data[right]
            right += 1
            now += 1

    # 어느 한 쪽이 빈 데이터가 되었을 때
    # left의 데이터가 남아 있을 때 data에 모든 데이터를 덮어씀
    while left < len(left_data):
        data[now] = left_data[left]
        left += 1
        now += 1

    # 어느 한 쪽이 빈 데이터가 되었을 때
    # right의 데이터가 남아 있을 때 data에 모든 데이터를 덮어씀
    while right < len(right_data):
        data[now] = right_data[right]
        right += 1
        now += 1

# rawdata = []
# for _ in range(int(input())):
#     rawdata.append(int(input()))
rawdata = [5,4,8,9,0,1,2,3,7,6]
merge(rawdata)
for i in rawdata:
    print(i)

# 풀이 2 - python에는 sorted(list) 함수가 내장되어 있음
# rawdata = []
# for _ in range(int(input())):
#     rawdata.append(int(input()))
rawdata = [5,4,8,9,0,1,2,3,7,6]
for i in sorted(rawdata):
    print(i)


# 10989 번
# 문제
# N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다.
# 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.
# 출력
# 첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

# 풀이 1 - 메모리 초과, 모든 배열을 할당하면 메모리가 초과됨
from sys import stdin
input = stdin.readline

def counting(data): # 카운팅 정렬
    # data 정리를 위한 두 개의 list 생성
    # count list은 정렬하고자 하는 최대값의 크기 만큼 생성
    # result list은 정렬하고자 하는 데이터의 개수 크기 만큼 생성
    count = [0] * (max(data)+1)
    result = [0] * len(data)

    # count list에 정렬 데이터의 값을 index로 하여 위치 지정
    for da in data:
        count[da] += 1

    print(count)
    # count list의 값을 누적 적용
    for i in range(1,len(count)):
        count[i] += count[i-1]

    # 각 데이터마다 count list에서 index를 가져오고 원본 list에서 값을 가져와 result list에 입력
    for i in data:
        indexing = count[i]
        result[indexing - 1] = i
        # 중복 데이터 입력을 위해 필요함
        count[i] -= 1

    return result

rawdata = [1,7,6,43,435,42,3,4,6567,3,345,656]
# rawdata=[]
# for _ in range(int(input())):
#     rawdata.append(int(input()))
for i in counting(rawdata):
    print(i)

# 풀이 2 - 메모리 초과, dict형 변환도 아쉬운 듯
from sys import stdin
input = stdin.readline

def counting(data): # 카운팅 정렬
    # data 정리를 위한 두 개의 변수 생성
    # count 를 list가 아닌 dict 형으로 바꾸는 것이 메모리에서 이익일 것 같음
    count = {}
    result = []

    # count dict에 정렬 데이터의 값을 저장
    for da in data:
        try:
            count[da] += 1
        except:
            count[da]= 1

    # for 문으로 각 데이터의 index를 부여하고, count dict에서 개수를 가져와서 정렬
    for i in range(max(data)+1):
        while i in count and count[i] != 0:
            result.append(i)
            count[i] -= 1

    return result

rawdata = [1,2,2,1,5,6,3,4,3]
# rawdata=[]
# for _ in range(int(input())):
#     rawdata.append(int(input()))
for i in counting(rawdata):
    print(i)

# 풀이 3
from sys import stdin
input = stdin.readline

n = int(input())
# 입력받는 데이터는 1~10,000, 총 10,000,000 개의 데이터임
rawdata=[0] * (10000+1)

# 입력 받은 데이터를 index로 하여 데이터 입력
for _ in range(n):
    rawdata[int(input())] += 1

# 1~10,000에 대해서 데이터가 존재하면 출력
for i in range(1,10000+1):
    for j in range(rawdata[i]):
        print(i)


# 2557 번
# 문제
# 두 숫자 R1과 R2가 있을 때, 두 수의 평균 S는 (R1+R2)/2와 같다.
# 상근이는 정인이 생일 선물로 두 숫자 R1과 R2를 주려고 한다.
# 생일 파티에서 상근이는 정인이에게 이 두 숫자를 말해주고, 정인이는 이 숫자를 받아 적는다.
# 그리고 나서 기쁜 마음으로 1년동안 이 숫자를 외우면서 산다.
# 상근이는 R1과 R2를 엄청난 고민 끝에 정했다.
# 작년에는 R1과 R2를 까먹어서 아무 숫자나 정해서 주었기 때문에,
# 올해는 까먹지 않기 위해서 평균 S도 같이 기억하려고 한다.
# 오늘은 정인이 생일이다.
# 5분 후에 상근이는 생일 선물로 두 숫자 R1과 R2를 말해주어야 하지만,
# 안타깝게도 R2를 까먹고 말았다.
# 하지만 R1과 S는 기억하고 있다!
# 상근이를 도와 R2가 몇 인지 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 두 정수 R1과 S가 주어진다. 두 수는 -1000보다 크거나 같고, 1000보다 작거나 같다.
# 출력
# 첫째 줄에 R2를 출력한다.

R1, S = map(int,input().split())
print(2*S - R1)


# 10699 번
# 문제
# 서울의 오늘 날짜를 출력하는 프로그램을 작성하시오.
# 입력
# 입력은 없다.
# 출력
# 서울의 오늘 날짜를 "YYYY-MM-DD" 형식으로 출력한다.

from datetime import datetime
print(datetime.now().date())


# 7287 번
# 문제
# 자신이 백준 온라인 저지(BOJ)에서 맞은 문제의 수와 아이디를 그대로 출력하는 프로그램을 작성하시오.
# 입력
# 이 문제는 입력이 없다.
# 출력
# 첫 줄에 자신이 맞은 문제의 수, 둘째 줄에 아이디를 출력한다.
print("110\ncatpic")


# 2530 번
# 문제
# KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 간편하게 만드는 인공지능 오븐을 개발하려고 한다.
# 인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 인공지능 오븐에 넣으면 된다.
# 그러면 인공지능 오븐은 오븐구이가 끝나는 시간을 초 단위로 자동적으로 계산한다.
# 또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다.
# 훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 초 단위로 주어졌을 때,
# 오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에는 현재 시각이 나온다.
# 현재 시각은 시 A (0 ≤ A ≤ 23), 분 B (0 ≤ B ≤ 59)와 초 C (0 ≤ C ≤ 59)가 정수로
# 빈칸을 사이에 두고 순서대로 주어진다.
# 두 번째 줄에는 요리하는 데 필요한 시간 D (0 ≤ D ≤ 500,000)가 초 단위로 주어진다.
# 출력
# 첫째 줄에 종료되는 시각의 시, 분, 초을 공백을 사이에 두고 출력한다.
# (단, 시는 0부터 23까지의 정수이며, 분, 초는 0부터 59까지의 정수이다.
# 디지털 시계는 23시 59분 59초에서 1초가 지나면 0시 0분 0초가 된다.)

from datetime import *
from random import *
from time import time as time2
from time import sleep
comb = []
timechk1 = []
timechk2 = []
count = 0
while count<10:
    count+=1
    h = randint(0,23)
    m = randint(0,59)
    s = randint(0,59)
    sec = randint(0, 500000)
    comb.append([h,m,s,sec])

    # 풀이 1; 86400으로 시간초 나눠서 풀이
    # h,m,s=map(int,input().split())
    start = time2()
    delta = datetime.combine(date(1,1,1),time(h,m,s))+timedelta(seconds=sec%86400)
    a = str(delta.time()).split(":")
    for i in range(len(a)):
        a[i] = int(a[i])
    # print(*a)
    sleep(0.001)
    timechk1.append(time2()-start)

    # 풀이 2; 입력된 시간초 그대로 풀이
    start = time2()
    # h,m,s=map(int,input().split())
    delta = datetime.combine(date(1,1,1),time(h,m,s))+timedelta(seconds=sec)
    a = str(delta.time()).split(":")
    for i in range(len(a)):
        a[i] = int(a[i])
    # print(*a)
    sleep(0.001)
    timechk2.append(time2() - start)
print(comb)
print(sum(timechk1)/len(timechk1))
print(sum(timechk2)/len(timechk2))


# 2914 번
# 문제
# 창영이는 노래 여러 개를 이어서 부르는 가수이다.
# 유명한 노래의 비슷한 멜로디를 이어서 부르면서
# 언제 곡이 넘어갔는지 모르게 만드는 것이 창영이 노래의 특징이다.
# 이런 노래로 상업적으로 엄청난 성공을 거둔 창영이에게 큰 시련이 찾아왔다.
# 그것은 바로 저작권이었다.
# 창영이의 노래에 포함되어 있는 멜로디는
# 모두 저작권이 다른 사람에게 있는 노래이다.
# 따라서, 이 음악으로 상업적인 활동을 했기 때문에, 저작권 협회에 저작권료를 내야한다.
# 창영이는 자신의 앨범에 포함되어있는 저작권이 있는 멜로디의 평균값을 구해보기로 했다.
# 이 값은 아래와 같이 구할 수 있다.
# (창영이 앨범에 수록된 곡에 포함되어 있는 저작권이 있는 멜로디의 개수) / (앨범에 수록된 곡의 개수)
# 이때, 평균값은 항상 올림을 해서 정수로 만들어야 한다.
# 예를 들어, 창영이의 1집 앨범 "영창에서 영원히 영창피아노를 친다"에 총 38개 곡이 수록되어 있고,
# 이 앨범에 저작권이 있는 멜로디가 894개가 있다면, 평균값은 23.53이 되고 올림해서 24가 된다.
# 매니저 강산이는 얼마나 많은 사람에게 저작권료를 주어야 하는지 궁금해졌다.
# 강산이가 알고 있는 정보는 앨범에 수록되어 있는 곡의 개수와 위에서 구한 평균값이다.
# 이때, 적어도 몇 곡이 저작권이 있는 멜로디인지 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 앨범에 수록된 곡의 개수 A와 평균값 I가 주어진다. (1 ≤ A, I ≤ 100)
# 출력
# 첫째 줄에 적어도 몇 곡이 저작권이 있는 멜로디인지 출력한다.

A, I = map(int,input().split())
print((I-1)*A+1)


# 5355 번
# 문제
# 겨울 방학에 달에 다녀온 상근이는 여름 방학 때는 화성에 갔다 올 예정이다. (3996번)
# 화성에서는 지구와는 조금 다른 연산자 @, %, #을 사용한다.
# @는 3을 곱하고, %는 5를 더하며, #는 7을 빼는 연산자이다.
# 따라서, 화성에서는 수학 식의 가장 앞에 수가 하나 있고, 그 다음에는 연산자가 있다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T가 주어진다.
# 다음 줄에는 화성 수학식이 한 줄에 하나씩 주어진다.
# 입력으로 주어지는 수는 정수이거나 소수 첫째 자리까지 주어지며, 0 이상 100 이하이다.
# 연산자는 최대 3개 주어진다.
# 출력
# 각 테스트 케이스에 대해서, 화성 수학식의 결과를 계산한 다음에, 소수점 둘째 자리까지 출력한다.

def Mars(*calc):
    calc=calc[0]
    num = float(calc[0])
    for i in calc[1:]:
        if i == "@":
            num*=3
        elif i == "%":
            num+=5
        elif i == "#":
            num-=7
    return num

for i in range(int(input())):
    num = Mars(input().split())
    print(f"{num:.2f}")


# 2935 번
# 문제
# 수업 시간에 떠드는 두 학생이 있다.
# 두 학생은 수업에 집중하는 대신에 글로벌 경제 위기에 대해서 토론하고 있었다.
# 토론이 점점 과열되면서 두 학생은 목소리를 높였고, 결국 선생님은 크게 분노하였다.
# 이렇게 학생들이 수업 시간에 떠드는 문제는 어떻게 해결해야 할까?
# 얼마전에 초등학교 선생님으로 취직한 상근이는 이 문제를 수학 문제로 해결한다.
# 학생들을 진정시키기 위해 칠판에 수학 문제를 써주고, 아이들에게 조용히 이 문제를 풀게 한다.
# 학생들이 문제를 금방 풀고 다시 떠드는 것을 방지하기 위해서, 숫자를 매우 크게 한다.
# 아직 초등학교이기 때문에, 학생들은 덧셈과 곱셈만 배웠다.
# 또, 아직 10의 제곱꼴을 제외한 다른 수는 학교에서 배우지 않았기 때문에,
# 선생님이 써주는 수는 모두 10의 제곱 형태이다.
# 쉬는 시간까지 문제를 푸는 것을 막기 위해서, 선생님이 써주는 숫자는 최대 100자리이다.
# 칠판에 쓰여 있는 문제가 주어졌을 때, 결과를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 양의 정수 A가 주어진다.
# 둘째 줄에 연산자 + 또는 *가 주어진다.
# 셋째 줄에 양의 정수 B가 주어진다.
# A와 B는 모두 10의 제곱 형태이고, 길이는 최대 100자리이다.
# 출력
# 첫째 줄에 결과를 출력한다. 결과는 A+B 또는 A*B이며, 입력에서 주어지는 연산자에 의해 결정된다.

from sys import *
input = stdin.readline
A = int(input())
calc = input().strip()
B = int(input())
if calc == "+":
    print(A+B)
else:
    print(A*B)


# 10817 번
# 문제
# 세 정수 A, B, C가 주어진다. 이때, 두 번째로 큰 정수를 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 세 정수 A, B, C가 공백으로 구분되어 주어진다. (1 ≤ A, B, C ≤ 100)
# 출력
# 두 번째로 큰 정수를 출력한다.

# 풀이 1; 리스트 만들고, 정렬 후 출력
bs = list(map(int,input().split()))
bs.sort()
print(bs[1])

# 풀이 2; 정렬된 리스트에서 출력
print(sorted(list(map(int,input().split())))[1])

# 1789 번
# 문제
# 서로 다른 N개의 자연수의 합이 S라고 한다. S를 알 때, 자연수 N의 최댓값은 얼마일까?
# 입력
# 첫째 줄에 자연수 S(1 ≤ S ≤ 4,294,967,295)가 주어진다.
# 출력
# 첫째 줄에 자연수 N의 최댓값을 출력한다.

S=int(input())
N=int((2*S+0.25)**0.5-0.5)
D=S-N*(N+1)/2
if D<=N:
    print(N)
else:
    print(N+1)

# 4101 번
# 문제
# 두 양의 정수가 주어졌을 때, 첫 번째 수가 두 번째 수보다 큰지 구하는 프로그램을 작성하시오.
# 입력
# 입력은 여러 개의 테스트 케이스로 이루어져 있다.
# 각 테스트 케이스는 한 줄로 이루어져 있으며, 두 정수가 주어진다.
# 두 수는 백만보다 작거나 같은 양의 정수이다.
# 입력의 마지막 줄에는 0이 두 개 주어진다.
# 출력
# 각 테스트 케이스마다, 첫 번째 수가 두 번째 수보다 크면 Yes를, 아니면 No를 한 줄에 하나씩 출력한다.
while True:
    a, b = map(int,input().split())
    if a*b == 0:
        break
    if a > b:
        print("Yes")
    else:
        print("No")


# 10156 번
# 문제
# 동수는 제과점에 과자를 사러 가는데 현재 가진 돈이 모자랄 경우 부모님께 모자란 돈을 받으려고 한다.
# 과자 한 개의 가격이 K, 사려고 하는 과자의 개수가 N이고, 현재 가진 돈의 액수를 M이라 할 때
# 여러분은 동수가 부모님께 받아야 하는 모자란 돈을 계산하려고 한다.
# 예를 들어, 과자 한 개의 가격이 30원, 사려고 하는 과자의 개수가 4개, 현재 동수가 가진 돈이 100원이라 할 때,
# 동수가 부모님께 받아야 하는 돈은 20원이다.
# 과자 한 개의 가격이 250원, 사려고 하는 과자의 개수가 2개, 현재 동수가 가진 돈이 140원이라 할 때,
# 동수가 부모님께 받아야 하는 돈은 360원이다.
# 과자 한 개의 가격이 20원, 사려고 하는 과자의 개수가 6개, 현재 동수가 가진 돈이 120원이라 할 때
# 동수가 부모님께 받아야 하는 돈은 0원이다.
# 과자 한 개의 가격이 20원, 사려고 하는 과자의 개수가 10개, 현재 동수가 가진 돈이 320원이라 할 때
# 동수가 부모님께 받아야 하는 돈은 역시 0원이다.
# 과자 한 개의 가격, 사려고 하는 과자의 개수와 동수가 현재 가진 돈의 액수가 주어질 때
# 동수가 부모님께 받아야 하는 돈의 액수를 출력하는 프로그램을 작성하시오.
# 입력
# 첫 번째 줄에는 과자 한 개의 가격 K, 사려고 하는 과자의 개수 N, 현재 동수가 가진 돈 M이 각각 공백을 사이에 두고 주어진다.
# 단, K, N은 1,000 이하의 양의 정수이고, M은 10만 이하의 양의 정수이다. (1 ≤ K, N ≤ 1,000, 1 ≤ M ≤ 100,000이다.)
# 출력
# 첫 줄에 동수가 부모님께 받아야 하는 돈의 액수를 출력한다.

K, N, M = map(int,input().split())
if M >= K*N:
    print(0)
else:
    print(K*N-M)


# 2476 번
# 문제
# 1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다.
# 같은 눈이 3개가 나오면 10,000원+(같은 눈)×1,000원의 상금을 받게 된다.
# 같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다.
# 모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다.
# 예를 들어, 3개의 눈 3, 3, 6이 주어지면 상금은 1,000+3×100으로 계산되어 1,300원을 받게 된다.
# 또 3개의 눈이 2, 2, 2로 주어지면 10,000+2×1,000 으로 계산되어 12,000원을 받게 된다.
# 3개의 눈이 6, 2, 5로 주어지면 그 중 가장 큰 값이 6이므로 6×100으로 계산되어 600원을 상금으로 받게 된다.
# N(2 ≤ N ≤ 1,000)명이 주사위 게임에 참여하였을 때, 가장 많은 상금을 받은 사람의 상금을 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에는 참여하는 사람 수 N이 주어지고 그 다음 줄부터 N개의 줄에 사람들이 주사위를 던진 3개의 눈이 빈칸을 사이에 두고 각각 주어진다.
# 출력
# 첫째 줄에 가장 많은 상금을 받은 사람의 상금을 출력한다.

from sys import *
input = stdin.readline
reward = []
for _ in range(int(input())):
    dice = sorted(list(map(int,input().split())))
    if dice.count(dice[1]) == 1:
        reward.append(100*dice[2])
    elif dice.count(dice[1]) == 2:
        reward.append(1000+100*dice[1])
    else:
        reward.append(10000+1000*dice[1])
print(max(reward))


# 2754 번
# 문제
# 어떤 사람의 C언어 성적이 주어졌을 때, 평점은 몇 점인지 출력하는 프로그램을 작성하시오.
# A+: 4.3, A0: 4.0, A-: 3.7
# B+: 3.3, B0: 3.0, B-: 2.7
# C+: 2.3, C0: 2.0, C-: 1.7
# D+: 1.3, D0: 1.0, D-: 0.7
# F: 0.0
# 입력
# 첫째 줄에 C언어 성적이 주어진다. 성적은 문제에서 설명한 13가지 중 하나이다.
# 출력
# 첫째 줄에 C언어 평점을 출력한다.
score={
    "A+": 4.3,
    "A0": 4.0,
    "A-": 3.7,
    "B+": 3.3,
    "B0": 3.0,
    "B-": 2.7,
    "C+": 2.3,
    "C0": 2.0,
    "C-": 1.7,
    "D+": 1.3,
    "D0": 1.0,
    "D-": 0.7,
    "F": 0.0
}
print(score[input()])


# 7567 번
# 문제
# 그릇을 바닥에 놓았을 때 그 높이는 10cm 이다.
# 그런데 두 개의 그릇을 같은 방향으로 포개면 그 높이는 5cm만 증가된다.
# 만일 그릇이 서로 반대방향으로 쌓이면 높이는 그릇만큼, 즉 10cm 늘어난다. 그릇을 괄호 기호로 나타내어 설명해보자.
# 편의상 그릇이 쌓여지는 방향은 왼쪽에서 오른쪽이라고 가정한다.
# 그림에서 ‘(’은 그릇이 바닥에 바로 놓인 상태를 나타내며, ‘)’은 그릇이 거꾸로 놓인 상태를 나타낸다.
# 만일 그릇이 포개진 모양이 ((((와 같다면 전체의 높이는 25cm가 된다.
# 왜냐하면 처음 바닥에 있는 그릇의 높이가 10cm이고 이후 같은 방향으로 3개의 그릇이 포개져 있으므로 늘어난 높이는 5+5+5=15 이기 때문이다.
# ()()와 같은 경우라면 그 높이는 10*4=40cm가 된다.
# 여러분은 입력에 주어진 모양대로 그릇을 쌓을 때 최종의 전체 그릇 높이를 계산해서 출력해야 한다.
# 즉 처음 입력으로 주어진 각 그릇의 방향은 바꿀 수 없다.
# 입력
# 첫 줄에는 괄호문자로만 이루어진 문자열이 주어진다.
# 입력 문자열에서 열린 괄호 ‘(’은 바로 놓인 그릇, 닫힌 괄호 ‘)’은 거꾸로 놓인 그릇을 나타난다.
# 문자열의 길이는 3이상 50 이하이다.
# 출력
# 여러분은 그릇 방향이 괄호 문자로 표시된 문자열을 읽어서 그 최종의 높이를 정수로 출력해야 한다.

def bowl(bowls):
    height = 10
    while len(bowls)>1:
        first = bowls[0]
        comp = bowls[1]
        if first == comp:
            height += 5
        else:
            height += 10
        bowls.remove(bowls[0])
    return height
print(bowl(list(input())))


# 5063 번
# 문제
# 상근이는 TGN사의 사장이다.
# TGN은 Teenager Game Network의 약자 같지만,
# 사실 Temporary Group Name의 약자이다.
# 이 회사는 청소년을 위한 앱을 만드는 회사이다.
# 일년에 걸친 개발기간 끝에 드디어 앱을 완성했고, 이제 팔기만 하면 된다.
# 상근이는 데이트를 인간의 두뇌로 이해할 수 없을 정도로 많이 한다.
# 따라서 엄청난 데이트 비용이 필요하다.
# 상근이는 광고를 적절히 해서 수익을 최대한 올리려고 한다.
# 어느 날 하늘을 바라보던 상근이는 시리우스의 기운을 받게 되었고,
# 광고 효과를 예측하는 능력을 갖게 되었다.
# 광고 효과가 주어졌을 때,
# 광고를 해야할지 말아야할지 결정하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 테스트 케이스의 개수 N이 주어진다.
# 다음 N개의 줄에는 3개의 정수 r, e, c가 주어진다.
# r은 광고를 하지 않았을 때 수익,
# e는 광고를 했을 때의 수익,
# c는 광고 비용이다. (-106 ≤ r,e ≤ 106, 0 ≤ c ≤ 106)
# 출력
# 각 테스트 케이스에 대해서,
# 광고를 해야 하면 "advertise",
# 하지 않아야 하면 "do not advertise",
# 광고를 해도 수익이 차이가 없다면 "does not matter"를 출력한다.

for _ in range(int(input())):
    r, e, c = map(int,input().split())
    if r > e-c:
        print("do not advertise")
    elif r < e-c:
        print("advertise")
    else:
        print("does not matter")

# 10102 번
# 문제
# A와 B가 한 오디션 프로의 결승전에 진출했다.
# 결승전의 승자는 심사위원의 투표로 결정된다.
# 심사위원의 투표 결과가 주어졌을 때,
# 어떤 사람이 우승하는지 구하는 프로그램을 작성하시오.
# 입력
# 입력은 총 두 줄로 이루어져 있다.
# 첫째 줄에는 심사위원의 수 V (1 ≤  V ≤  15)가 주어지고,
# 둘째 줄에는 각 심사위원이 누구에게 투표했는지가 주어진다.
# A와 B는 각각 그 참가자를 나타낸다.
# 출력
# A가 받은 표가 B보다 많은 경우에는 A
# B가 받은 표가 A보다 많은 경우에는 B
# 같은 경우에는 Tie
# 를 출력한다.

vote = [0]*int(input())
vote = list(input())
a = vote.count("A")
b = vote.count("B")
if a>b:
    print("A")
elif a<b:
    print("B")
else:
    print("Tie")


# 10886 번
# 문제
# 준희는 자기가 팀에서 귀여움을 담당하고 있다고 생각한다.
# 하지만 연수가 볼 때 그 의견은 뭔가 좀 잘못된 것 같았다.
# 그렇기에 설문조사를 하여 준희가 귀여운지 아닌지 알아보기로 했다.
# 입력
# 첫 번째 줄에 설문조사를 한 사람의 수 N (1 ≤ N ≤ 101, N은 홀수)가 주어진다.
# 다음 N개의 줄에는 각 줄마다
# 각 사람이 설문 조사에 어떤 의견을 표명했는지를 나타내는 정수가 주어진다.
# 0은 준희가 귀엽지 않다고 했다는 뜻이고, 1은 준희가 귀엽다고 했다는 뜻이다.
# 출력
# 준희가 귀엽지 않다는 의견이 더 많을 경우 "Junhee is not cute!"를 출력하고
# 귀엽다는 의견이 많을 경우 "Junhee is cute!"를 출력하라.

cute = []
for _ in range(int(input())):
    cute.append(input())
if cute.count("0")>len(cute)/2:
    print("Junhee is not cute!")
else:
    print("Junhee is cute!")


# 10988 번
# 문제
# 알파벳 소문자로만 이루어진 단어가 주어진다.
# 이때, 이 단어가 팰린드롬인지 아닌지 확인하는 프로그램을 작성하시오.
# 팰린드롬이란 앞으로 읽을 때와 거꾸로 읽을 때 똑같은 단어를 말한다.
# level, noon은 팰린드롬이고, baekjoon, online, judge는 팰린드롬이 아니다.
# 입력
# 첫째 줄에 단어가 주어진다.
# 단어의 길이는 1보다 크거나 같고,
# 100보다 작거나 같으며, 알파벳 소문자로만 이루어져 있다.
# 출력
# 첫째 줄에 팰린드롬이면 1, 아니면 0을 출력한다.

pal = input()
if pal[::-1] in pal:
    print(1)
else:
    print(0)


# 5717 번
# 문제
# 상근이의 남자 친구의 수와 여자 친구의 수가 주어졌을 때,
# 친구는 총 몇 명인지 구하는 프로그램을 작성하시오.
# 입력
# 입력은 여러 개의 테스트 케이스로 이루어져 있다.
# 각 테스트 케이스는 두 정수 M과 F로 이루어져 있으며,
# 각각은 상근이의 남자 친구의 수와 여자 친구의 수이다. (1 ≤ M, F ≤ 5)
# 입력의 마지막 줄에는 0이 두 개 주어진다.
# 출력
# 각 테스트 케이스마다 상근이의 친구의 수를 출력한다.

while True:
    M, F = map(int,input().split())
    if M*F == 0:
        break
    else:
        print(M+F)


# 9610 번
# 문제
# 2차원 좌표 상의 여러 점의 좌표 (x,y)가 주어졌을 때,
# 각 사분면과 축에 점이 몇 개 있는지 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 점의 개수 n (1 ≤ n ≤ 1000)이 주어진다.
# 다음 n개 줄에는 점의 좌표 (xi, yi)가 주어진다. (-106 ≤ xi, yi ≤ 106)
# 출력
# 각 사분면과 축에 점이 몇 개 있는지를 예제 출력과 같은 형식으로 출력한다.

plots = [0]*5
for _ in range(int(input())):
    x, y = map(int,input().split())
    if x*y == 0:
        i = 0
    elif x>0 and y>0:
        i = 1
    elif x<0 and y>0:
        i = 2
    elif x<0 and y<0:
        i = 3
    else:
        i = 4
    plots[i] += 1
print(f"""Q1: {plots[1]}
Q2: {plots[2]}
Q3: {plots[3]}
Q4: {plots[4]}
AXIS: {plots[0]}""")


# 9506 번
# 문제
# 어떤 숫자 n이 자신을 제외한 모든 약수들의 합과 같으면, 그 수를 완전수라고 한다.
# 예를 들어 6은 6 = 1 + 2 + 3 으로 완전수이다.
# n이 완전수인지 아닌지 판단해주는 프로그램을 작성하라.
# 입력
# 입력은 테스트 케이스마다 한 줄 간격으로 n이 주어진다. (2 < n < 100, 000)
# 입력의 마지막엔 -1이 주어진다.
# 출력
# 테스트케이스 마다 한줄에 하나씩 출력해야 한다.
# n이 완전수라면, n을 n이 아닌 약수들의 합으로 나타내어 출력한다(예제 출력 참고).
# 이때, 약수들은 오름차순으로 나열해야 한다.
# n이 완전수가 아니라면 n is NOT perfect. 를 출력한다.

def diviser(num):
    ran = int(num/2) + 1
    global divs
    divs = []
    for i in range(1,ran):
        if num%i==0:
            divs.append(i)

def printout(*nums):
    print(f"{sum(divs)} = ",end="")
    for i in nums[0]:
        if i == nums[0][-1]:
            print(i)
        else:
            print(i, end=" + ")
# from time import sleep
while 1:
    a = int(input())
# for a in range(2,100000+1):
    if a == -1:
        break
    diviser(a)
    if a == sum(divs):
        printout(divs)
        # sleep(2)
    else:
        print(f"{a} is NOT perfect.")