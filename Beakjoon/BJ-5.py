# 2592 번
# 문제
# 어떤 수들이 있을 때, 그 수들을 대표하는 값으로 가장 흔하게 쓰이는 것은 평균이다.
# 평균은 주어진 모든 수의 합을 수의 개수로 나눈 것이다.
# 예를 들어 10, 40, 30, 60, 30, 20, 60, 30, 40, 50의 평균은
# (10 + 40 + 30 + 60 + 30 + 20 + 60 + 30 + 40 + 50) / 10 = 370 / 10 = 37이 된다.
# 평균 이외의 또 다른 대표값으로 최빈값이라는 것이 있다.
# 최빈값은 주어진 수들 가운데 가장 많이 나타나는 수이다.
# 예를 들어 10, 40, 30, 60, 30, 20, 60, 30, 40, 50이 주어질 경우,
# 30이 세 번, 40과 60이 각각 두 번, 10, 20, 50이 각각 한 번씩 나오므로, 최빈값은 30이 된다.
# 열 개의 자연수가 주어질 때 이들의 평균과 최빈값을 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄부터 열 번째 줄까지 한 줄에 하나씩 자연수가 주어진다.
# 주어지는 자연수는 1,000 보다 작은 10의 배수이다.
# 출력
# 첫째 줄에는 평균을 출력하고, 둘째 줄에는 최빈값을 출력한다.
# 최빈값이 둘 이상일 경우 그 중 하나만 출력한다.
# 평균과 최빈값은 모두 자연수이다.

nums = []
for _ in range(10):
    nums.append(int(input()))
nums_dic = {}
for i in nums:
    try:
        nums_dic[i]+=1
    except:
        nums_dic[i]=1
print(f"{int(sum(nums)/len(nums))}\n{max(nums_dic,key=nums_dic.get)}")


# 2711 번
# 문제
# 고창영은 맨날 오타를 낸다.
# 창영이가 오타를 낸 문장과 오타를 낸 위치가 주어졌을 때,
# 오타를 지운 문자열을 출력하는 프로그램을 작성하시오.
# 창영이는 오타를 반드시 1개만 낸다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T(1<=T<=1,000)가 주어진다.
# 각 테스트 케이스는 한 줄로 구성되어 있다.
# 첫 숫자는 창영이가 오타를 낸 위치이고,
# 두 번째 문자열은 창영이가 친 문자열이다.
# 문자열의 가장 첫 문자는 1번째 문자이고,
# 문자열의 길이는 80을 넘지 않고, 대문자로만 이루어져 있다.
# 오타를 낸 위치는 문자열 길이보다 작거나 같다.
# 출력
# 각 테스트 케이스에 대해 오타를 지운 문자열을 출력한다.
for _ in range(int(input())):
    a, b = input().split()
    b_list = list(b)
    b_list.pop(int(a) - 1)
    print("".join(b_list))
    # print(b.remove(int(a)))


# 2953 번
# 문제
# "나는 요리사다"는 다섯 참가자들이 서로의 요리 실력을 뽐내는 티비 프로이다.
# 각 참가자는 자신있는 음식을 하나씩 만들어오고, 서로 다른 사람의 음식을 점수로 평가해준다.
# 점수는 1점부터 5점까지 있다.
# 각 참가자가 얻은 점수는 다른 사람이 평가해 준 점수의 합이다.
# 이 쇼의 우승자는 가장 많은 점수를 얻은 사람이 된다.
# 각 참가자가 얻은 평가 점수가 주어졌을 때, 우승자와 그의 점수를 구하는 프로그램을 작성하시오.
# 입력
# 총 다섯 개 줄에 각 참가자가 얻은 네 개의 평가 점수가 공백으로 구분되어 주어진다.
# 첫 번째 참가자부터 다섯 번째 참가자까지 순서대로 주어진다. 항상 우승자가 유일한 경우만 입력으로 주어진다.
# 출력
# 첫째 줄에 우승자의 번호와 그가 얻은 점수를 출력한다.

# 풀이 1 - list 사용
score=[0]*5
index = 1
max_score = 0
for i in range(5):
    score[i] = list(map(int,input().split()))
    if i == 0:
        max_score = sum(score[i])
    else:
        if sum(score[i]) > max_score:
            max_score = sum(score[i])
            index=i+1
print(index, max_score)

# 풀이 2 -  dict 사용
score={}
for i in range(5):
    score[i+1]=sum(list(map(int,input().split())))
max_ = max(score,key=score.get)
print(max_, score[max_])


# 1292 번
# 문제
# 동호는 내년에 초등학교를 입학한다.
# 그래서 동호 어머니는 수학 선행 학습을 위해 쉽게 푸는 문제를 동호에게 주었다.
# 이 문제는 다음과 같다.
# 1을 한 번, 2를 두 번, 3을 세 번, 이런 식으로 1 2 2 3 3 3 4 4 4 4 5 ..
# 이러한 수열을 만들고 어느 일정한 구간을 주면 그 구간의 합을 구하는 것이다.
# 하지만 동호는 현재 더 어려운 문제를 푸느라 바쁘기에 우리가 동호를 도와주자.
# 입력
# 첫째 줄에 구간의 시작과 끝을 나타내는 정수 A, B(1 ≤ A ≤ B ≤ 1,000)가 주어진다.
# 즉, 수열에서 A번째 숫자부터 B번째 숫자까지 합을 구하면 된다.
# 출력
# 첫 줄에 구간에 속하는 숫자의 합을 출력한다.

a, b = map(int,input().split())
an = int(1/2+(2*a)**0.5) # a가 속해있는 군
al = a-an*(an-1)/2
sum_an_1 = an*(an-1)*(2*an-1)/6 + al*an
bn = int(1/2+(2*b)**0.5) # b가 속해있는 군
bl = b-bn*(bn-1)/2
sum_bn_1 = bn*(bn-1)*(2*bn-1)/6 + bl*bn
print(int(sum_bn_1-sum_an_1+an))


# 3460 번
# 문제
# 양의 정수 n이 주어졌을 때, 이를 이진수로 나타냈을 때 1의 위치를 모두 찾는 프로그램을 작성하시오.
# 최하위 비트(least significant bit, lsb)의 위치는 0이다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T가 주어진다.
# 각 테스트 케이스는 한 줄로 이루어져 있고, n이 주어진다. (1 ≤ T ≤ 10, 1 ≤ n ≤ 10**6)
# 출력
# 각 테스트 케이스에 대해서, 1의 위치를 공백으로 구분해서 줄 하나에 출력한다. 위치가 낮은 것부터 출력한다.

bin = [2**x for x in range(20)]
bin.reverse()
for _ in range(int(input())):
    n = int(input())
    binary = []
    bin_fin=[]
    for i in bin:
        binary.append(n//i)
        n%=i
    binary.reverse()
    bin_fin = [x for x in range(len(binary)) if binary[x]==1]
    print(*bin_fin)


# 10807 번
# 문제
# 총 N개의 정수가 주어졌을 때, 정수 v가 몇 개인지 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 정수의 개수 N(1 ≤ N ≤ 100)이 주어진다.
# 둘째 줄에는 정수가 공백으로 구분되어져있다.
# 셋째 줄에는 찾으려고 하는 정수 v가 주어진다.
# 입력으로 주어지는 정수와 v는 -100보다 크거나 같으며, 100보다 작거나 같다.
# 출력
# 첫째 줄에 입력으로 주어진 N개의 정수 중에 v가 몇 개인지 출력한다.

N=[0]*int(input())
N=input().split()
print(N.count(input()))


# 2822 번
# 문제
# 상근이는 퀴즈쇼의 PD이다. 이 퀴즈쇼의 참가자는 총 8개 문제를 푼다.
# 참가자는 각 문제를 풀고, 그 문제를 풀었을 때 얻는 점수는 문제를 풀기 시작한 시간부터 경과한 시간과 난이도로 결정한다.
# 문제를 풀지 못한 경우에는 0점을 받는다.
# 참가자의 총 점수는 가장 높은 점수 5개의 합이다.
# 상근이는 잠시 여자친구와 전화 통화를 하느라 참가자의 점수를 계산하지 않고 있었다.
# 참가자의 8개 문제 점수가 주어졌을 때, 총 점수를 구하는 프로그램을 작성하시오.
# 입력
# 8개 줄에 걸쳐서 각 문제에 대한 참가자의 점수가 주어진다.
# 점수는 0보다 크거나 같고, 150보다 작거나 같다. 모든 문제에 대한 점수는 서로 다르다.
# 입력으로 주어지는 순서대로 1번 문제, 2번 문제, ... 8번 문제이다.
# 출력
# 첫째 줄에 참가자의 총점을 출력한다. 둘째 줄에는 어떤 문제가 최종 점수에 포함되는지를 공백으로 구분하여 출력한다. 출력은 문제 번호가 증가하는 순서이어야 한다.

score = [0]*8
for i in range(8):
    score[i] = int(input())
sort_score = score.copy()
sort_score.sort(reverse=True)
print(sum(sort_score[:5]))
idx = [score.index(x)+1 for x in sort_score[:5]]
print(*sorted(idx))


# 5054 번
# 문제
# 선영이는 쇼핑하러 긴 도로에 자주 간다.
# 선영이는 주차를 세상에서 가장 귀찮아 하기 때문에, 아무데나 주차를 한다.
# 주차를 한 후에는 가려고 했던 상점으로 걸어 간다.
# 어느 날, 선영이는 다리가 너무 아파서 병원에 갔다.
# 의사는 선영이에게 되도록 조금 걷거나, 쇼핑을 하지 말라고 했다.
# 선영이는 쇼핑을 버릴 수 없다. 그녀의 특기를 발휘해서 가장 좋은 주차 자리를 찾으려고 한다.
# 긴 도로는 일직선이다. 또, 모든 상점의 위치는 정수 좌표를 가지고 있다.
# 주차장은 모든 정수 좌표마다 하나씩 있으며, 선영이를 위해 항상 비어있다.
# 선영이는 주차비를 아끼기 위해서 쇼핑을 마치기 전 까지는 주차한 차를 이동시키지 않을 것이다.
# 선영이는 힘이 매우 세기 때문에, 자신이 쇼핑한 물건을 모두 들지 못하는 경우는 없다.
# 가려고 계획한 상점은 모두 방문해야 한다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 t가 주어진다. (1 ≤ t ≤ 100)
# 모든 테스트 케이스는 두 줄로 이루어져 있다.
# 첫째 줄에는 선영이가 방문할 상점의 수 n이 주어지며 (1 ≤ n ≤ 20),
# 둘째 줄에는 상점의 위치가 주어진다. (0 ≤ xi ≤ 99)
# 출력
# 선영이가 가려고 했던 모든 상점을 방문하고 차로 돌아오기 위해 걸어야 하는 거리의 최솟값을 출력한다.

for _ in range(int(input())):
    shop = [0]*int(input())
    shop = list(map(int,input().split()))
    print(2*(max(shop)-min(shop)))


# 2752 번
# 문제
# 동규는 세수를 하다가 정렬이 하고싶어졌다.
# 숫자 세 개를 생각한 뒤에, 이를 오름차순으로 정렬하고 싶어 졌다.
# 숫자 세 개가 주어졌을 때, 가장 작은 수, 그 다음 수, 가장 큰 수를 출력하는 프로그램을 작성하시오.
# 입력
# 숫자 세 개가 주어진다. 이 숫자는 1보다 크거나 같고, 1,000,000보다 작거나 같다. 이 숫자는 모두 다르다.
# 출력
# 제일 작은 수, 그 다음 수, 제일 큰 수를 차례대로 출력한다.

print(*sorted(list(map(int,input().split()))))


# 5543 번
# 문제
# 상근날드에서 가장 잘 팔리는 메뉴는 세트 메뉴이다.
# 주문할 때, 자신이 원하는 햄버거와 음료를 하나씩 골라,
# 세트로 구매하면, 가격의 합계에서 50원을 뺀 가격이 세트 메뉴의 가격이 된다.
# 햄버거는 총 3종류 상덕버거, 중덕버거, 하덕버거가 있고, 음료는 콜라와 사이다 두 종류가 있다.
# 햄버거와 음료의 가격이 주어졌을 때, 가장 싼 세트 메뉴의 가격을 출력하는 프로그램을 작성하시오.
# 입력
# 입력은 총 다섯 줄이다.
# 첫째 줄에는 상덕버거, 둘째 줄에는 중덕버거, 셋째 줄에는 하덕버거의 가격이 주어진다.
# 넷째 줄에는 콜라의 가격, 다섯째 줄에는 사이다의 가격이 주어진다.
# 모든 가격은 100원 이상, 2000원 이하이다.
# 출력
# 첫째 줄에 가장 싼 세트 메뉴의 가격을 출력한다.

hamberger=[]
drink=[]
for _ in range(3):
    hamberger.append(int(input()))
for _ in range(2):
    drink.append(int(input()))
print(min(hamberger)+min(drink)-50)


# 2587 번
# 문제
# 어떤 수들이 있을 때, 그 수들을 대표하는 값으로 가장 흔하게 쓰이는 것은 평균이다.
# 평균은 주어진 모든 수의 합을 수의 개수로 나눈 것이다.
# 예를 들어 10, 40, 30, 60, 30의 평균은 (10 + 40 + 30 + 60 + 30) / 5 = 170 / 5 = 34가 된다.
# 평균 이외의 또 다른 대표값으로 중앙값이라는 것이 있다.
# 중앙값은 주어진 수를 크기 순서대로 늘어 놓았을 때 가장 중앙에 놓인 값이다.
# 예를 들어 10, 40, 30, 60, 30의 경우, 크기 순서대로 늘어 놓으면
# 10 30 30 40 60
# 이 되고 따라서 중앙값은 30이 된다.
# 다섯 개의 자연수가 주어질 때 이들의 평균과 중앙값을 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄부터 다섯 번째 줄까지 한 줄에 하나씩 자연수가 주어진다.
# 주어지는 자연수는 100 보다 작은 10의 배수이다.
# 출력
# 첫째 줄에는 평균을 출력하고, 둘째 줄에는 중앙값을 출력한다.
# 평균과 중앙값은 모두 자연수이다.

nums=[0]*5
for _ in range(5):
    nums[_]=int(input())
print(f"{int(sum(nums)/len(nums))}\n{sorted(nums)[2]}")


# 1427 번
# 문제
# 배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자.
# 입력
# 첫째 줄에 정렬하려고 하는 수 N이 주어진다.
# N은 1,000,000,000보다 작거나 같은 자연수이다.
# 출력
# 첫째 줄에 자리수를 내림차순으로 정렬한 수를 출력한다.

a = list(input())
a.sort(reverse=True)
print("".join(a))


# 2309 번
# 문제
# 왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다.
# 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.
# 아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다.
# 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.
# 아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.
# 입력
# 아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다.
# 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.
# 출력
# 일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.

# 풀이 1 - intertools.combination 사용
from itertools import *
drf = [0]*9
for _ in range(9):
    drf[_] = int(input())
for i in combinations(drf,7):
    if sum(i) == 100:
        for j in sorted(list(i)):
            print(j)
        break

# 풀이 2
drf = sorted([int(input()) for _ in range(9)]) # 입력 받음
fakedrf = sum(drf) - 100 # 가짜 난쟁이 키의 합
for i in drf:
    drf_mirror = drf.copy()
    drf_mirror.remove(i)
    for j in drf_mirror:
        if i+j == fakedrf:
            break
    if i + j == fakedrf:
        drf.remove(i)
        drf.remove(j)
        break
for i in drf:
    print(i)


# 9076 번
# 문제
# 한국 체조협회에서는 심판의 오심을 막기 위하여 점수 집계 시스템을 고치기로 하였다.
# 이전에는 5명의 심판이 1점부터 10점까지 정수의 점수를 주면 최고점과 최저점을 하나씩 제외한 점수의 합을 총점으로 하였다.
# 이를 보완하기 위해서 최고점과 최저점을 뺀 나머지 3명 점수의 최고점과 최저점의 차이가 4점 이상 나게 되면 점수 조정을 거쳐서 다시 점수를 매기려고 한다.
# 점수를 집계하여 총점을 계산하거나, 점수 조정을 거쳐서 다시 점수를 매기려고 하는 경우에는 총점 대신 KIN(Keep In Negotiation)을 출력하는 프로그램을 작성하시오.
# 입력
# 입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 10)가 주어진다.
# 각 테스트 케이스는 한 줄에 다섯 심판이 준 점수 다섯 개의 정수 Ni(1 ≤ Ni ≤ 10, i = 1, 2, ..., 5)가 하나의 공백을 사이에 두고 주어진다.
# 출력
# 각 테스트 케이스에 대해서 총점을 한 줄씩 출력한다.
# 만일 점수 조정을 거쳐서 다시 점수를 매기려고 하는 경우에는 총점 대신 KIN을 출력한다.

for _ in range(int(input())):
    score = list(map(int,input().split()))
    score.remove(max(score))
    score.remove(min(score))
    if abs(max(score)-min(score))>3:
        print("KIN")
    else:
        print(sum(score))


# 2693 번
# 문제
# 배열 A가 주어졌을 때, N번째 큰 값을 출력하는 프로그램을 작성하시오.
# 배열 A의 크기는 항상 10이고, 자연수만 가지고 있다. N은 항상 3이다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다.
# 각 테스트 케이스는 한 줄로 이루어져 있고, 배열 A의 원소 10개가 공백으로 구분되어 주어진다.
# 이 원소는 1보다 크거나 같고, 1,000보다 작거나 같은 자연수이다.
# 출력
# 각 테스트 케이스에 대해 한 줄에 하나씩 배열 A에서 3번째 큰 값을 출력한다.

for _ in range(int(input())):
    print(sorted(list(map(int,input().split())))[-3])


# 5176 번
# 문제
# 이번 ACM-ICPC 대회의 자리는 참가자들이 직접 정한다.
# 참가자들은 예비 소집일에 자신이 원하는 자리를 미리 정해놓았고, 대회 당일에 어제 적어놓은 자리에 앉으면 된다.
# 여러명이 같은 자리를 적어논 경우에는, 먼저 도착한 사람이 그 자리에 앉게되고, 앉지 못한 사람은 대회에 참가할 수 없다.
# 각 사람이 선호하는 자리가 주어졌을 때, 대회에 참가하지 못하는 사람의 수를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 테스트 케이스의 개수 K가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어 있다.
# 첫째 줄에 참가자의 수 P와 자리의 수 M이 주어진다. (1 ≤ P, M ≤ 500)
# 다음 P개 줄에는 각 참가자가 원하는 자리가 주어진다.
# 자리는 1번부터 M번까지 있다.
# 입력으로 주어지는 참가자가 도착하는 순서이다.
# 출력
# 각 테스트 케이스에 대해서, 대회에 참가하지 못하는 사람의 수를 출력한다.

for _ in range(int(input())):
    seat={}
    loose = 0
    P, M = map(int,input().split())
    for i in range(P):
        m = int(input())
        try:
            if seat[m]:
                loose+=1
        except:
            seat[m] = i+1
    print(loose)


# 10773 번
# 문제
# 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.
# 재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.
# 재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.
# 재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!
# 입력
# 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)
# 이후 K개의 줄에 정수가 1개씩 주어진다.
# 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 "0" 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다.
# 정수가 "0"일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.
# 출력
# 재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 2**31-1보다 작거나 같은 정수이다.

# from sys import * # 쓰면 116ms, 안 쓰면 4004ms
# input = stdin.readline
money = []
for _ in range(int(input())):
    m = int(input())
    if m != 0:
        money.append(m)
    else:
        money.pop(-1)
print(sum(money))


# 3040 번
# 문제
# 매일 매일 일곱 난쟁이는 광산으로 일을 하러 간다. 난
# 쟁이가 일을 하는 동안 백설공주는 그들을 위해 저녁 식사를 준비한다.
# 백설공주는 의자 일곱개, 접시 일곱개, 나이프 일곱개를 준비한다.
# 어느 날 광산에서 아홉 난쟁이가 돌아왔다.
# (왜 그리고 어떻게 아홉 난쟁이가 돌아왔는지는 아무도 모른다)
# 아홉 난쟁이는 각각 자신이 백설공주의 일곱 난쟁이라고 우기고 있다.
# 백설공주는 이런 일이 생길 것을 대비해서, 난쟁이가 쓰고 다니는 모자에 100보다 작은 양의 정수를 적어 놓았다.
# 사실 백설 공주는 공주가 되기 전에 매우 유명한 수학자였다.
# 따라서, 일곱 난쟁이의 모자에 쓰여 있는 숫자의 합이 100이 되도록 적어 놓았다.
# 아홉 난쟁이의 모자에 쓰여 있는 수가 주어졌을 때, 일곱 난쟁이를 찾는 프로그램을 작성하시오.
# (아홉 개의 수 중 합이 100이 되는 일곱 개의 수를 찾으시오)
# 입력
# 총 아홉개 줄에 1보다 크거나 같고 99보다 작거나 같은 자연수가 주어진다.
# 모든 숫자는 서로 다르다. 또, 항상 답이 유일한 경우만 입력으로 주어진다.
# 출력
# 일곱 난쟁이가 쓴 모자에 쓰여 있는 수를 한 줄에 하나씩 출력한다.

from itertools import *
drf = [0]*9
for _ in range(9):
    drf[_] = int(input())
for i in combinations(drf,7):
    if sum(i) == 100:
        for j in sorted(list(i)):
            print(j)
        break


# 3058 번
# 문제
# 7개의 자연수가 주어질 때, 이들 중 짝수인 자연수들을 모두 골라 그 합을 구하고,
# 고른 짝수들 중 최솟값을 찾는 프로그램을 작성하시오.
# 예를 들어, 7개의 자연수 13, 78, 39, 42, 54, 93, 86가 주어지면
# 이들 중 짝수는 78, 42, 54, 86이므로 그 합은 78 + 42 + 54 + 86 = 260 이 되고,
# 42 < 54 < 78 < 86 이므로 짝수들 중 최솟값은 42가 된다.
# 입력
# 입력은 T개의 테스트 데이터로 구성된다.
# 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다.
# 각 테스트 데이터는 한 줄로 구성되어 있고, 7개의 자연수가 공백으로 구분되어 있다.
# 입력으로 주어지는 자연수는 1보다 크거나 같고, 100보다 작거나 같다.
# 7개의 자연수 중 적어도 하나는 짝수이다.
# 출력
# 각 테스트 데이터에 대해, 7개 자연수 중 짝수의 합과 최솟값을 공백으로 구분하여 한 줄에 하나씩 출력한다.

for _ in range(int(input())):
    nums = list(map(int,input().split()))
    even_nums = [x for x in nums if x%2 ==0]
    print(f"{sum(even_nums)} {min(even_nums)}")


# 5800 번
# 문제
# 한상덕은 이번에 중덕 고등학교에 새로 부임한 교장 선생님이다.
# 교장 선생님으로서 첫 번째 일은 각 반의 수학 시험 성적의 통계를 내는 일이다.
# 중덕 고등학교 각 반의 학생들의 수학 시험 성적이 주어졌을 때,
# 최대 점수, 최소 점수, 점수 차이를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 중덕 고등학교에 있는 반의 수 K (1 ≤ K ≤ 100)가 주어진다.
# 다음 K개 줄에는 각 반의 학생수 N (2 ≤ N ≤ 50)과 각 학생의 수학 성적이 주어진다.
# 시험 성적은 0보다 크거나 같고, 100보다 작거나 같은 정수이고, 공백으로 나누어져 있다.
# 출력
# 각 반에 대한 출력은 다음과 같이 두 줄로 이루어져 있다.
# 첫째 줄에는 "Class X"를 출력한다. X는 반의 번호이며 입력으로 주어진 순서대로 1부터 증가한다.
# 둘째 줄에는 가장 높은 점수, 낮은 점수, 성적을 내림차순으로 정렬했을 때 가장 큰 인접한 점수 차이를 예제 출력과 같은 형식으로 출력한다.

for i in range(int(input())):
    score = list(map(int,input().split()))
    stud = score[0]
    score = sorted(score[1:])
    gap=0
    for j in range(1,len(score)):
        j_=score[j]-score[j-1]
        if j_>gap:
            gap=j_
    print(f"Class {i+1}\nMax {max(score)}, Min {min(score)}, Largest gap {gap}")


# 5576 번
# 문제
# 최근 온라인에서의 프로그래밍 콘테스트가 열렸다.
# W 대학과 K 대학의 컴퓨터 클럽은 이전부터 라이벌 관계에있어,
# 이 콘테스트를 이용하여 양자의 우열을 정하자라는 것이되었다.
# 이번이 두 대학에서 모두 10 명씩이 콘테스트에 참여했다.
# 긴 논의 끝에 참가한 10 명 중 득점이 높은 사람에서 3 명의 점수를 합산하여 대학의 득점으로하기로 했다.
# W 대학 및 K 대학 참가자의 점수 데이터가 주어진다.
# 이때, 각각의 대학의 점수를 계산하는 프로그램을 작성하라.
# 입력
# 입력은 20 행으로 구성된다.
# 1 번째 줄부터 10 번째 줄에는 W 대학의 각 참가자의 점수를 나타내는 정수가
# 11 번째 줄부터 20 번째 줄에는 K 대학의 각 참가자의 점수를 나타내는 정수가 적혀있다.
# 이 정수는 모두 0 이상 100 이하이다.
# 출력
# W 대학 점수와 K 대학의 점수를 순서대로 공백으로 구분하여 출력하라.

W = sorted([int(input()) for _ in range(10)])
K = sorted([int(input()) for _ in range(10)])
print(f"{sum(W[-3:])} {sum(K[-3:])}")


# 11047 번
# 문제
# 준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.
# 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다.
# 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)
# 둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다.
# (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)
# 출력
# 첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.

N, K = map(int,input().split())
coin = sorted([int(input()) for i in range(N)],reverse=True)
cnt = 0
for i in coin:
    if K//i>0:
        cnt+=K//i
        K%=i
print(cnt)


# 2743 번
# 문제
# 알파벳으로만 이루어진 단어를 입력받아, 그 길이를 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 영어 소문자와 대문자로만 이루어진 단어가 주어진다. 단어의 길이는 최대 100이다.
# 출력
# 첫째 줄에 입력으로 주어진 단어의 길이를 출력한다.
print(len(input()))


# 2744 번
# 문제
# 영어 소문자와 대문자로 이루어진 단어를 입력받은 뒤,
# 대문자는 소문자로, 소문자는 대문자로 바꾸어 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 영어 소문자와 대문자로만 이루어진 단어가 주어진다.
# 단어의 길이는 최대 100이다.
# 출력
# 첫째 줄에 입력으로 주어진 단어에서 대문자는 소문자로, 소문자는 대문자로 바꾼 단어를 출력한다.

# 풀이 1 - 글자마다 불러와서 전환
a = input()
b=""
for i in a:
    if i<"a":
        b+=i.lower()
    else:
        b+=i.upper()
print(b)

# 풀이 2 - swapcase 사용
print(input().swapcase())


# 2902 번
# 문제
# KMP 알고리즘이 KMP인 이유는 이를 만든 사람의 성이 Knuth, Morris, Prett이기 때문이다.
# 이렇게 알고리즘에는 발견한 사람의 성을 따서 이름을 붙이는 경우가 많다.
# 또 다른 예로, 유명한 비대칭 암호화 알고리즘 RSA는 이를 만든 사람의 이름이 Rivest, Shamir, Adleman이다.
# 사람들은 이렇게 사람 성이 들어간 알고리즘을 두 가지 형태로 부른다.
# 첫 번째는 성을 모두 쓰고, 이를 하이픈(-)으로 이어 붙인 것이다.
# 예를 들면, Knuth-Morris-Pratt이다. 이것을 긴 형태라고 부른다.
# 두 번째로 짧은 형태는 만든 사람의 성의 첫 글자만 따서 부르는 것이다.
# 예를 들면, KMP이다.
# 동혁이는 매일매일 자신이 한 일을 모두 메모장에 적어놓는다.
# 잠을 자기 전에, 오늘 하루 무엇을 했는지 되새겨 보는 것으로 하루를 마감한다.
# 하루는 이 메모를 보던 중, 지금까지 긴 형태와 짧은 형태를 섞어서 적어 놓은 것을 발견했다.
# 이렇게 긴 형태로 하루 일을 기록하다가는 메모장 가격이 부담되어 파산될 것이 뻔하기 때문에, 앞으로는 짧은 형태로 기록하려고 한다.
# 긴 형태의 알고리즘 이름이 주어졌을 때, 이를 짧은 형태로 바꾸어 출력하는 프로그램을 작성하시오.
# 입력
# 입력은 한 줄로 이루어져 있고, 최대 100글자의 영어 알파벳 대문자, 소문자, 그리고 하이픈 ('-', 아스키코드 45)로만 이루어져 있다.
# 첫 번째 글자는 항상 대문자이다. 그리고, 하이픈 뒤에는 반드시 대문자이다. 그 외의 모든 문자는 모두 소문자이다.
# 출력
# 첫 줄에 짧은 형태 이름을 출력한다.

name = input().split("-")
for i in name:
    print(i[0],end="")


# 1357 번
# 문제
# 어떤 수 X가 주어졌을 때, X의 모든 자리수가 역순이 된 수를 얻을 수 있다.
# Rev(X)를 X의 모든 자리수를 역순으로 만드는 함수라고 하자.
# 예를 들어, X=123일 때, Rev(X) = 321이다. 그리고, X=100일 때, Rev(X) = 1이다.
# 두 양의 정수 X와 Y가 주어졌을 때, Rev(Rev(X) + Rev(Y))를 구하는 프로그램을 작성하시오
# 입력
# 첫째 줄에 수 X와 Y가 주어진다.
# X와 Y는 1,000보다 작거나 같은 자연수이다.
# 출력
# 첫째 줄에 문제의 정답을 출력한다.

# 함수 사용
def rev(a):
    return int("".join(reversed(list(str(a))))) #reversed
    # return int("".join(list(str(a))[::-1])) # [::-1]

a, b = input().split()
print(rev(rev(a)+rev(b)))


# 10987 번
# 문제
# 알파벳 소문자로만 이루어진 단어가 주어진다.
# 이때, 모음(a, e, i, o, u)의 개수를 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 단어가 주어진다.
# 단어의 길이는 1보다 크거나 같고, 100보다 작거나 같으며, 알파벳 소문자로만 이루어져 있다.
# 출력
# 첫째 줄에 모음의 개수를 출력한다.

# 풀이 1
vowel=["a","e","i","o","u"]
cnt=0
word=list(input())
for _ in vowel:
    cnt+=word.count(_)
print(cnt)

# 풀이 2
vowel=["a","e","i","o","u"]
word=list(input())
print(sum([word.count(i) for i in vowel]))


# 4458 번
# 문제
# 문장을 읽은 뒤, 줄의 첫 글자를 대문자로 바꾸는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 줄의 수 N이 주어진다.
# 다음 N개의 줄에는 문장이 주어진다.
# 각 문장에 들어있는 글자의 수는 30을 넘지 않는다.
# 모든 줄의 첫 번째 글자는 알파벳이다.
# 출력
# 각 줄의 첫글자를 대문자로 바꾼뒤 출력한다.

# 풀이 1 - 복잡하게 푸는 법 (멍청이)
for _ in range(int(input())):
    sts = input()
    for __ in range(len(sts)):
        if __ == 0:
            print(sts[__].upper(),end="")
        elif __ == len(sts)-1:
            print(sts[__])
        else:
            print(sts[__],end="")

# 풀이 1-1 - 마지막줄 수정
for _ in range(int(input())):
    sts = input()
    for __ in range(len(sts)):
        if __ == 0:
            print(sts[__].upper(),end="")
        else:
            print(sts[__],end="")
    print("")


# 풀이 2 - 간단하게 푸는 법
for _ in range(int(input())):
    sts = input()
    print(sts[0].upper(),end="")
    print(sts[1:])


# 11721 번
# 문제
# 알파벳 소문자와 대문자로만 이루어진 길이가 N인 단어가 주어진다.
# 한 줄에 10글자씩 끊어서 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 단어가 주어진다.
# 단어는 알파벳 소문자와 대문자로만 이루어져 있으며, 길이는 100을 넘지 않는다.
# 길이가 0인 단어는 주어지지 않는다.
# 출력
# 입력으로 주어진 단어를 열 개씩 끊어서 한 줄에 하나씩 출력한다.
# 단어의 길이가 10의 배수가 아닌 경우에는 마지막 줄에는 10개 미만의 글자만 출력할 수도 있다.

a = input()
l = len(a)
for i in range(l//10):
    print(a[i*10:i*10+10])
if l%10 != 0:
    print(a[l//10*10:])


# 10821 번
# 문제
# 숫자와 콤마로만 이루어진 문자열 S가 주어진다.
# 이때, S에 포함되어있는 정수의 개수를 구하는 프로그램을 작성하시오.
# S의 첫 문자와 마지막 문자는 항상 숫자이고, 콤마는 연속해서 주어지지 않는다.
# 또, 0으로 시작하는 정수는 주어지지 않는다.
# 입력
# 첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 100이다.
# 출력
# 문자열 S에 포함되어 있는 정수의 개수를 출력한다.

print(len(list(input().split(","))))


# 10808 번
# 문제
# 알파벳 소문자로만 이루어진 단어 S가 주어진다.
# 각 알파벳이 단어에 몇 개가 포함되어 있는지 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 단어 S가 주어진다.
# 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다.
# 출력
# 단어에 포함되어 있는 a의 개수, b의 개수, …, z의 개수를 공백으로 구분해서 출력한다.

a = [chr(i) for i in range(97,123)]
word=input()
print(*[word.count(i) for i in a])


# 5218 번
# 문제
# 길이가 같은 두 단어가 주어졌을 때, 각 단어에 포함된 모든 글자의 알파벳 거리를 구하는 프로그램을 작성하시오.
# 두 글자 x와 y 사이의 알파벳 거리를 구하려면, 먼저 각 알파벳에 숫자를 할당해야 한다.
# 'A'=1, 'B' = 2, ..., 'Z' = 26.
# 그 다음 y ≥ x인 경우에는 y-x, y < x인 경우에는 (y+26) - x가 알파벳 거리가 된다.
# 예를 들어, 'B'와 'D' 사이의 거리는 4 - 2 = 2이고,
# 'D'와 'B' 사이의 거리는 (2+26) - 4 = 24이다.
# 입력
# 첫째 줄에 테스트 케이스의 수 (< 100)가 주어진다.
# 각 테스트 케이스는 한 줄로 이루어져 있고, 두 단어가 공백으로 구분되어져 있다.
# 단어의 길이는 4보다 크거나 같고, 20보다 작거나 같으며, 알파벳 대문자로만 이루어져 있다.
# 출력
# 각 테스트 케이스 마다 각 글자의 알파벳 거리를 공백으로 구분해 출력한다.
# 출력 형식
# 정확한 출력 형식은 제출에서 언어를 Java로 설정하면 확인할 수 있다.

al={}
for i in range(26):
    al[chr(i+65)]=i+1
for _ in range(int(input())):
    a, b = input().split()
    dist=[]
    for i in range(len(a)):
        dis=al[b[i]]-al[a[i]]
        if dis>=0:
            dist.append(str(dis))
        else:
            dist.append(str(dis+26))
    print(f"""Distances: {" ".join(dist)}""")


# 11655 번
# 문제
# ROT13은 카이사르 암호의 일종으로 영어 알파벳을 13글자씩 밀어서 만든다.
# 예를 들어, "Baekjoon Online Judge"를 ROT13으로 암호화하면 "Onrxwbba Bayvar Whqtr"가 된다.
# ROT13으로 암호화한 내용을 원래 내용으로 바꾸려면 암호화한 문자열을 다시 ROT13하면 된다.
# 앞에서 암호화한 문자열 "Onrxwbba Bayvar Whqtr"에 다시 ROT13을 적용하면 "Baekjoon Online Judge"가 된다.
# ROT13은 알파벳 대문자와 소문자에만 적용할 수 있다.
# 알파벳이 아닌 글자는 원래 글자 그대로 남아 있어야 한다.
# 예를 들어, "One is 1"을 ROT13으로 암호화하면 "Bar vf 1"이 된다.
# 문자열이 주어졌을 때, "ROT13"으로 암호화한 다음 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 알파벳 대문자, 소문자, 공백, 숫자로만 이루어진 문자열 S가 주어진다.
# S의 길이는 100을 넘지 않는다.
# 출력
# 첫째 줄에 S를 ROT13으로 암호화한 내용을 출력한다.

sts=input()
for i in sts:
    o=ord(i)
    if 64<o<78 or 96<o<110: # A~M, a~m
        print(chr(o+13),end="")
    elif 77<o<91 or 109<o<123: # N~Z, n~z
        print(chr(o-13),end="")
    else:
        print(i,end="")
print("")


# 11170 번
# 문제
# N부터 M까지의 수들을 종이에 적었을 때 종이에 적힌 0들을 세는 프로그램을 작성하라.
# 예를 들어, N, M이 각각 0, 10일 때 0을 세면 0에 하나, 10에 하나가 있으므로 답은 2이다.
# 입력
# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
# 각 줄에는 N과 M이 주어진다.
# 1 ≤ T ≤ 20
# 0 ≤ N ≤ M ≤ 1,000,000
# 출력
# 각각의 테스트 케이스마다 N부터 M까지의 0의 개수를 출력한다.

for _ in range(int(input())):
    N,M=map(int,input().split())
    print(sum([str(i).count("0") for i in range(N,M+1)]))


# 11365 번
# 문제
# 당신은 길을 가다가 이상한 쪽지를 발견했다.
# 그 쪽지에는 암호가 적혀 있었는데, 똑똑한 당신은 암호가 뒤집으면 해독된다는 것을 발견했다.
# 이 암호를 해독하는 프로그램을 작성하시오.
# 입력
# 한 줄에 하나의 암호가 주어진다.
# 암호의 길이는 500을 넘지 않는다.
# 마지막 줄에는 "END"가 주어진다. (END는 해독하지 않는다.)
# 출력
# 각 암호가 해독된 것을 한 줄에 하나씩 출력한다.

while True:
    sts=input()
    if sts=="END":
        break
    print(sts[::-1])


# 9086 번
# 문제
# 문자열을 입력으로 주면 문자열의 첫 글자와 마지막 글자를 출력하는 프로그램을 작성하시오.
# 입력
# 입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 10)가 주어진다.
# 각 테스트 케이스는 한 줄에 하나의 문자열이 주어진다.
# 문자열은 알파벳 A~Z 대문자로 이루어지며 알파벳 사이에 공백은 없으며 문자열의 길이는 1000보다 작다.
# 출력
# 각 테스트 케이스에 대해서 주어진 문자열의 첫 글자와 마지막 글자를 연속하여 출력한다.

for _ in range(int(input())):
    n=input()
    print(n[0]+n[-1])



# 11653 번
# 문제
# 정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.
# 출력
# N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.

# 풀이 1 - 소수를 먼저 입력해 놓고 나누기, 시간 초과
primenumber = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
               101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,
               211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,
               307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,
               401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,
               503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,
               601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,
               701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,
               809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,
               907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
N = int(input())
while N>1:
    for i in primenumber:
        if N % i == 0:
            print(i)
            N /= i
            break

# 풀이 2 - N 이하의 소수를 구하고 소인수분해 하기, 시간 초과
def prime(n):
    if n == 1:
        return 0
    else:
        m = int(n**0.5+1)
        for i in range(2,m):
            if n % i == 0:
                n = 0
                break
        return n

N = int(input())
N_list = [i for i in range(N+1)]
M_list = list(set(map(prime,N_list)))
M_list.sort()
if 0 in M_list:
    M_list.remove(0)
while N>1:
    for i in M_list:
        if N % i == 0:
            print(i)
            N /= i
            break
        else:
            M_list.remove(i)

# 풀이 3 - 약수 중 소수만 찾아내기
N=int(input())
n=[i for i in range(2,N+1) if N%i==0]
for i in n:
    m = [j for j in n[n.index(i)+1:] if j%i==0]
    for j in m:
        try:
            n.remove(j)
        except:
            continue
for i in n:
    while True:
        if N%i==0:
            N//=i
            print(i)
        else:
            break


# 11718 번
# 문제
# 입력 받은 대로 출력하는 프로그램을 작성하시오.
# 입력
# 입력이 주어진다.
# 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다.
# 각 줄은 100글자를 넘지 않으며, 빈 줄은 주어지지 않는다.
# 또, 각 줄은 공백으로 시작하지 않고, 공백으로 끝나지 않는다.
# 출력
# 입력받은 그대로 출력한다.

# from sys import * # sys.stdin.readline 은 EOFError를 Raise하지 않기 때문에 EOFError를 제외할 다른 구문이 필요
# input=stdin.readline
while True:
    try:
        print(input())
    except EOFError:
        break


# 11719 번
# 문제
# 입력 받은 대로 출력하는 프로그램을 작성하시오.
# 입력
# 입력이 주어진다.
# 입력은 최대 100줄로 이루어져 있고, 알파벳 소문자, 대문자, 공백, 숫자로만 이루어져 있다.
# 각 줄은 100글자를 넘지 않으며, 빈 줄이 주어질 수도 있고, 각 줄의 앞 뒤에 공백이 있을 수도 있다.
# 출력
# 입력받은 그대로 출력한다.

while True:
    try:
        print(input())
    except EOFError:
        break


# 11650 번
# 문제
# 2차원 평면 위의 점 N개가 주어진다.
# 좌표를 x좌표가 증가하는 순으로,
# x좌표가 같으면 y좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다.
# 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000)
# 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.
# 출력
# 첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.

# from sys import * # 넣고 452 ms, 안 넣고 4184 ms
# input=stdin.readline
n=[]
for _ in range(int(input())):
    n.append(list(map(int,input().split())))
n.sort()
for i in n:
    print(*i)


# 11651 번
# 문제
# 2차원 평면 위의 점 N개가 주어진다.
# 좌표를 y좌표가 증가하는 순으로,
# y좌표가 같으면 x좌표가 증가하는 순서로 정렬한 다음 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 점의 개수 N (1 ≤ N ≤ 100,000)이 주어진다.
# 둘째 줄부터 N개의 줄에는 i번점의 위치 xi와 yi가 주어진다. (-100,000 ≤ xi, yi ≤ 100,000)
# 좌표는 항상 정수이고, 위치가 같은 두 점은 없다.
# 출력
# 첫째 줄부터 N개의 줄에 점을 정렬한 결과를 출력한다.

from sys import * # 넣고 432 ms, 안 넣고 시간 초과
input=stdin.readline
n=[]
for _ in range(int(input())):
    n.append(list(map(int,input().split()))[::-1])
n.sort()
for i in n:
    print(*(i[::-1]))


# 1924 번
# 문제
# 오늘은 2007년 1월 1일 월요일이다.
# 그렇다면 2007년 x월 y일은 무슨 요일일까?
# 이를 알아내는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 빈 칸을 사이에 두고 x(1 ≤ x ≤ 12)와 y(1 ≤ y ≤ 31)이 주어진다.
# 참고로 2007년에는 1, 3, 5, 7, 8, 10, 12월은 31일까지, 4, 6, 9, 11월은 30일까지, 2월은 28일까지 있다.
# 출력
# 첫째 줄에 x월 y일이 무슨 요일인지에 따라 SUN, MON, TUE, WED, THU, FRI, SAT중 하나를 출력한다.

from datetime import *
wd=["MON","TUE","WED","THU","FRI","SAT","SUN"]
y,m,d=map(int,("2007 "+input()).split())
print(wd[date(y,m,d).weekday()])