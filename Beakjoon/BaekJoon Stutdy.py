# 10828 번 - 완료
# 문제
# 정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.
# 명령은 총 다섯 가지이다.
# push X: 정수 X를 스택에 넣는 연산이다.
# pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다.
# 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.
# size: 스택에 들어있는 정수의 개수를 출력한다.
# empty: 스택이 비어있으면 1, 아니면 0을 출력한다.
# top: 스택의 가장 위에 있는 정수를 출력한다.
# 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.
# 입력
# 첫째 줄에 주어지는 명령의 수 N (1 ≤ N ≤ 10,000)이 주어진다.
# 둘째 줄부터 N개의 줄에는 명령이 하나씩 주어진다.
# 주어지는 정수는 1보다 크거나 같고, 100,000보다 작거나 같다.
# 문제에 나와있지 않은 명령이 주어지는 경우는 없다.
# 출력
# 출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.

# 풀이 1
from sys import stdin
input = stdin.readline

global stk
stk = []

def func(a):
    # for _ in a:
    #   print(type(_))
    if "push" in a:
        stk.append(int(a[1]))
    elif "pop" in a:
        if len(stk) == 0:
            print(-1)
        else:
            print(stk[-1])
            return stk.pop(-1)
    elif "size" in a:
        return print(len(stk))
    elif "empty" in a:
        if len(stk) == 0:
            print(1)
        else:
            print(0)
    else:
        if len(stk) == 0:
            print(-1)
        else:
            print(stk[-1])

for _ in range(int(input())):
    func(list(map(str, input().split())))


# 2231 번 - 완료
# 문제
# 어떤 자연수 N이 있을 때, 그 자연수 N의 분해합은 N과 N을 이루는 각 자리수의 합을 의미한다.
# 어떤 자연수 M의 분해합이 N인 경우, M을 N의 생성자라 한다.
# 예를 들어, 245의 분해합은 256(=245+2+4+5)이 된다.
# 따라서 245는 256의 생성자가 된다.
# 물론, 어떤 자연수의 경우에는 생성자가 없을 수도 있다.
# 반대로, 생성자가 여러 개인 자연수도 있을 수 있다.
# 자연수 N이 주어졌을 때, N의 가장 작은 생성자를 구해내는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 자연수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
# 출력
# 첫째 줄에 답을 출력한다. 생성자가 없는 경우에는 0을 출력한다.

def separation(N):
  sep = [N]
  while N>=1:
    sep.append(N%10)
    N//=10
  return sum(sep)

N = int(input())
gen = [i for i in range(N-9*len(str(N)),N)]
sep = list(map(separation,gen))
if N in sep:
  print(gen[sep.index(N)])
else:
  print(0)


# 2798 번 - 완료
# 문제
# 카지노에서 제일 인기 있는 게임 블랙잭의 규칙은 상당히 쉽다.
# 카드의 합이 21을 넘지 않는 한도 내에서,
# 카드의 합을 최대한 크게 만드는 게임이다. 블랙잭은 카지노마다 다양한 규정이 있다.
# 한국 최고의 블랙잭 고수 김정인은 새로운 블랙잭 규칙을 만들어 상근, 창영이와 게임하려고 한다.
# 김정인 버전의 블랙잭에서 각 카드에는 양의 정수가 쓰여 있다.
# 그 다음, 딜러는 N장의 카드를 모두 숫자가 보이도록 바닥에 놓는다.
# 그런 후에 딜러는 숫자 M을 크게 외친다.
# 이제 플레이어는 제한된 시간 안에 N장의 카드 중에서 3장의 카드를 골라야 한다.
# 블랙잭 변형 게임이기 때문에,
# 플레이어가 고른 카드의 합은 M을 넘지 않으면서 M과 최대한 가깝게 만들어야 한다.
# N장의 카드에 써져 있는 숫자가 주어졌을 때,
# M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 구해 출력하시오.
# 입력
# 첫째 줄에 카드의 개수 N(3 ≤ N ≤ 100)과 M(10 ≤ M ≤ 300,000)이 주어진다.
# 둘째 줄에는 카드에 쓰여 있는 수가 주어지며, 이 값은 100,000을 넘지 않는 양의 정수이다.
# 합이 M을 넘지 않는 카드 3장을 찾을 수 있는 경우만 입력으로 주어진다.
# 출력
# 첫째 줄에 M을 넘지 않으면서 M에 최대한 가까운 카드 3장의 합을 출력한다.

from sys import stdin
input = stdin.readline

N, M = map(int,input().split())
cards = list(map(int,input().split()))
bj = []

for i in cards:
  # 파이썬 list는 =으로 복사할 경우 pointer가 두 개가 될 뿐 두 개의 list가 생성되지는 않음
  cards_j = cards.copy()
  cards_j.remove(i)
  for j in cards_j:
    cards_k = cards_j.copy()
    cards_k.remove(j)
    for k in cards_k:
      if i+j+k<=M:
        bj.append(i+j+k)

print(max(bj))

# 7568 번 - 완료
# 문제
# 우리는 사람의 덩치를 키와 몸무게, 이 두 개의 값으로 표현하여 그 등수를 매겨보려고 한다.
# 어떤 사람의 몸무게가 x kg이고 키가 y cm라면 이 사람의 덩치는 (x, y)로 표시된다.
# 두 사람 A 와 B의 덩치가 각각 (x, y), (p, q)라고 할 때
# x > p 그리고 y > q 이라면 우리는 A의 덩치가 B의 덩치보다 "더 크다"고 말한다.
# 예를 들어 어떤 A, B 두 사람의 덩치가 각각 (56, 177), (45, 165) 라고 한다면
# A의 덩치가 B보다 큰 셈이 된다.
# 그런데 서로 다른 덩치끼리 크기를 정할 수 없는 경우도 있다.
# 예를 들어 두 사람 C와 D의 덩치가 각각 (45, 181), (55, 173)이라면
# 몸무게는 D가 C보다 더 무겁고, 키는 C가 더 크므로,
# "덩치"로만 볼 때 C와 D는 누구도 상대방보다 더 크다고 말할 수 없다.
# N명의 집단에서 각 사람의 덩치 등수는 자신보다 더 "큰 덩치"의 사람의 수로 정해진다.
# 만일 자신보다 더 큰 덩치의 사람이 k명이라면 그 사람의 덩치 등수는 k+1이 된다.
# 이렇게 등수를 결정하면 같은 덩치 등수를 가진 사람은 여러 명도 가능하다.
# 아래는 5명으로 이루어진 집단에서 각 사람의 덩치와 그 등수가 표시된 표이다.
# 이름	(몸무게, 키)	덩치 등수
# A	(55, 185)	2
# B	(58, 183)	2
# C	(88, 186)	1
# D	(60, 175)	2
# E	(46, 155)	5
# 위 표에서 C보다 더 큰 덩치의 사람이 없으므로 C는 1등이 된다.
# 그리고 A, B, D 각각의 덩치보다 큰 사람은 C뿐이므로 이들은 모두 2등이 된다.
# 그리고 E보다 큰 덩치는 A, B, C, D 이렇게 4명이므로 E의 덩치는 5등이 된다.
# 위 경우에 3등과 4등은 존재하지 않는다.
# 여러분은 학생 N명의 몸무게와 키가 담긴 입력을 읽어서
# 각 사람의 덩치 등수를 계산하여 출력해야 한다.
# 입력
# 첫 줄에는 전체 사람의 수 N이 주어진다.
# 그리고 이어지는 N개의 줄에는
# 각 사람의 몸무게와 키를 나타내는 양의 정수 x와 y가 하나의 공백을 두고 각각 나타난다.
# 출력
# 여러분은 입력에 나열된 사람의 덩치 등수를 구해서 그 순서대로 첫 줄에 출력해야 한다.
# 단, 각 덩치 등수는 공백문자로 분리되어야 한다.

N = int(input())
big = [0] * N
index = [i for i in range(N)]
orders = [0] * N
order = 1

for _ in range(N):
    big[_] = list(map(int, input().split()))

for i in index:
    index_j = index.copy()
    index_j.remove(i)
    for j in index_j:
        if (big[i][0] < big[j][0]) and (big[i][1] < big[j][1]):
            orders[i] += 1

orders = list(map(lambda x: x + 1, orders))

print(*orders)

# 9020 번 - 완료
# 문제
# 1보다 큰 자연수 중에서  1과 자기 자신을 제외한 약수가 없는 자연수를 소수라고 한다.
# 예를 들어, 5는 1과 5를 제외한 약수가 없기 때문에 소수이다.
# 하지만, 6은 6 = 2 × 3 이기 때문에 소수가 아니다.
# 골드바흐의 추측은 유명한 정수론의 미해결 문제로,
# 2보다 큰 모든 짝수는 두 소수의 합으로 나타낼 수 있다는 것이다.
# 이러한 수를 골드바흐 수라고 한다.
# 또, 짝수를 두 소수의 합으로 나타내는 표현을 그 수의 골드바흐 파티션이라고 한다.
# 예를 들면,
# 4 = 2 + 2, 6 = 3 + 3, 8 = 3 + 5, 10 = 5 + 5,
# 12 = 5 + 7, 14 = 3 + 11, 14 = 7 + 7이다.
# 10000보다 작거나 같은 모든 짝수 n에 대한 골드바흐 파티션은 존재한다.
# 2보다 큰 짝수 n이 주어졌을 때, n의 골드바흐 파티션을 출력하는 프로그램을 작성하시오.
# 만약 가능한 n의 골드바흐 파티션이 여러 가지인 경우에는 두 소수의 차이가 가장 작은 것을 출력한다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T가 주어진다.
# 각 테스트 케이스는 한 줄로 이루어져 있고 짝수 n이 주어진다.
# 출력
# 각 테스트 케이스에 대해서 주어진 n의 골드바흐 파티션을 출력한다.
# 출력하는 소수는 작은 것부터 먼저 출력하며, 공백으로 구분한다.

from sys import stdin

input = stdin.readline


def prime(n):
    if n == 1:
        return 0
    else:
        m = int(n ** 0.5 + 1)
        for i in range(2, m):
            if n % i == 0:
                n = 0
                break
        return n


# Prime을 매 회차 진행하지 말고, 한 번 만든 다음에 더 이상 하지 않도록 설정
No = [i for i in range(10000 + 1)]
Prime = list(set(map(prime, No)))[1:]
Prime.sort()

for _ in range(int(input())):
    n = int(input())
    Goldbach = {}
    for i in Prime:
        # i 가 n/2보다 작으면 continue하고 그 이상일 경우에만 순서쌍 확인
        if i < n / 2:
            continue
        if n - i in Prime:
            Goldbach = {
                "1st": n - i,
                "2nd": i,
            }
            break
    print(Goldbach["1st"], Goldbach["2nd"])


# 1436 번
# 문제
# 666은 종말을 나타내는 숫자라고 한다.
# 따라서, 많은 블록버스터 영화에서는 666이 들어간 제목을 많이 사용한다.
# 영화감독 숌은 세상의 종말 이라는 시리즈 영화의 감독이다.
# 조지 루카스는 스타워즈를 만들 때,
# 스타워즈 1, 스타워즈 2, 스타워즈 3, 스타워즈 4, 스타워즈 5, 스타워즈 6과 같이 이름을 지었고,
# 피터 잭슨은 반지의 제왕을 만들 때,
# 반지의 제왕 1, 반지의 제왕 2, 반지의 제왕 3과 같이 영화 제목을 지었다.
# 하지만 숌은 자신이 조지 루카스와 피터 잭슨을 뛰어넘는다는 것을 보여주기 위해서
# 영화 제목을 좀 다르게 만들기로 했다.
# 종말의 숫자란 어떤 수에 6이 적어도 3개이상 연속으로 들어가는 수를 말한다.
# 제일 작은 종말의 숫자는 666이고, 그 다음으로 큰 수는 1666, 2666, 3666, .... 과 같다.
# 따라서, 숌은 첫 번째 영화의 제목은 세상의 종말 666,
# 두 번째 영화의 제목은 세상의 종말 1666 이렇게 이름을 지을 것이다.
# 일반화해서 생각하면, N번째 영화의 제목은 세상의 종말 (N번째로 작은 종말의 숫자) 와 같다.
# 숌이 만든 N번째 영화의 제목에 들어간 숫자를 출력하는 프로그램을 작성하시오.
# 숌은 이 시리즈를 항상 차례대로 만들고, 다른 영화는 만들지 않는다.
# 입력
# 첫째 줄에 숫자 N이 주어진다. N은 10,000보다 작거나 같은 자연수이다.
# 출력
# 첫째 줄에 N번째 영화의 제목에 들어간 수를 출력한다.

# 풀이 1
def six(n):
  if "666" in str(n):
    return n
  else:
    return

sixes = list(set(map(six, range(1,4000000))))
sixes.remove(None)
sixes.sort()
N=int(input())
print(sixes[N-1])


# 2751 번
# 문제
# N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000,000)이 주어진다.
# 둘째 줄부터 N개의 줄에는 수가 주어진다.
# 이 수는 절댓값이 1,000,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.
# 출력
# 첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

# 풀이 1
from sys import stdin
input = stdin.readline

def merge(data): # 병합 정렬
    if len(data) <= 1:
        return

    cut = len(data) // 2
    left_data = data[:cut]
    right_data = data[cut:]

    merge(left_data)
    merge(right_data)
    # rawdata = [5,4,8,9,0,1,2,3,7,6] 일때
    # 1. left = 5, right = 4 // [4, 5]
    # 2. left = 9, right = 0 // [0, 9]
    # 3. left = 8, right = 0, 9 // [0, 8, 9]
    # 4. left = 4, 5, right = 0, 8, 9 // [0, 4, 5, 8, 9]
    # 5. left = 1, right= 2 // [1, 2]
    # 6. left = 7, right =6 // [6, 7]
    # 7. left = 3, right = 6, 7 // [3, 6, 7]
    # 8. left = 1, 2, right = 3, 6, 7 // [1, 2, 3, 6, 7]
    # 9. left= 0, 4, 5, 8, 9, right = 1, 2, 3, 6, 7 // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

    left = 0
    right = 0
    now = 0

    # 어느 한 쪽이 빈 데이터면 건너 뜀
    while left < len(left_data) and right < len(right_data):
        # 양 쪽 데이터 모두 빈 데이터가 아닐 때

        # left_data의 첫 번째 원소와 right_data의 첫 번째 원소를 비교
        if left_data[left] < right_data[right]:
            # right가 클 경우에
            # 원본 리스트의 첫 번째 자리에 left를 집어넣고 인덱스를 하나씩 이동
            data[now] = left_data[left]
            left += 1
            now += 1
        else:
            # left가 클 경우에
            # 원본 리스트의 첫 번째 자리에 right를 집어넣고 인덱스를 하나씩 이동
            data[now] = right_data[right]
            right += 1
            now += 1

    # 어느 한 쪽이 빈 데이터가 되었을 때
    # left의 데이터가 남아 있을 때 data에 모든 데이터를 덮어씀
    while left < len(left_data):
        data[now] = left_data[left]
        left += 1
        now += 1

    # 어느 한 쪽이 빈 데이터가 되었을 때
    # right의 데이터가 남아 있을 때 data에 모든 데이터를 덮어씀
    while right < len(right_data):
        data[now] = right_data[right]
        right += 1
        now += 1

# rawdata = []
# for _ in range(int(input())):
#     rawdata.append(int(input()))
rawdata = [5,4,8,9,0,1,2,3,7,6]
merge(rawdata)
for i in rawdata:
    print(i)

# 풀이 2 - python에는 sorted(list) 함수가 내장되어 있음
# rawdata = []
# for _ in range(int(input())):
#     rawdata.append(int(input()))
rawdata = [5,4,8,9,0,1,2,3,7,6]
for i in sorted(rawdata):
    print(i)


# 10989 번
# 문제
# N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 수의 개수 N(1 ≤ N ≤ 10,000,000)이 주어진다.
# 둘째 줄부터 N개의 줄에는 수가 주어진다. 이 수는 10,000보다 작거나 같은 자연수이다.
# 출력
# 첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

# 풀이 1 - 메모리 초과, 모든 배열을 할당하면 메모리가 초과됨
from sys import stdin
input = stdin.readline

def counting(data): # 카운팅 정렬
    # data 정리를 위한 두 개의 list 생성
    # count list은 정렬하고자 하는 최대값의 크기 만큼 생성
    # result list은 정렬하고자 하는 데이터의 개수 크기 만큼 생성
    count = [0] * (max(data)+1)
    result = [0] * len(data)

    # count list에 정렬 데이터의 값을 index로 하여 위치 지정
    for da in data:
        count[da] += 1

    print(count)
    # count list의 값을 누적 적용
    for i in range(1,len(count)):
        count[i] += count[i-1]

    # 각 데이터마다 count list에서 index를 가져오고 원본 list에서 값을 가져와 result list에 입력
    for i in data:
        indexing = count[i]
        result[indexing - 1] = i
        # 중복 데이터 입력을 위해 필요함
        count[i] -= 1

    return result

rawdata = [1,7,6,43,435,42,3,4,6567,3,345,656]
# rawdata=[]
# for _ in range(int(input())):
#     rawdata.append(int(input()))
for i in counting(rawdata):
    print(i)

# 풀이 2 - 메모리 초과, dict형 변환도 아쉬운 듯
from sys import stdin
input = stdin.readline

def counting(data): # 카운팅 정렬
    # data 정리를 위한 두 개의 변수 생성
    # count 를 list가 아닌 dict 형으로 바꾸는 것이 메모리에서 이익일 것 같음
    count = {}
    result = []

    # count dict에 정렬 데이터의 값을 저장
    for da in data:
        try:
            count[da] += 1
        except:
            count[da]= 1

    # for 문으로 각 데이터의 index를 부여하고, count dict에서 개수를 가져와서 정렬
    for i in range(max(data)+1):
        while i in count and count[i] != 0:
            result.append(i)
            count[i] -= 1

    return result

rawdata = [1,2,2,1,5,6,3,4,3]
# rawdata=[]
# for _ in range(int(input())):
#     rawdata.append(int(input()))
for i in counting(rawdata):
    print(i)

# 풀이 3
from sys import stdin
input = stdin.readline

n = int(input())
# 입력받는 데이터는 1~10,000, 총 10,000,000 개의 데이터임
rawdata=[0] * (10000+1)

# 입력 받은 데이터를 index로 하여 데이터 입력
for _ in range(n):
    rawdata[int(input())] += 1

# 1~10,000에 대해서 데이터가 존재하면 출력
for i in range(1,10000+1):
    for j in range(rawdata[i]):
        print(i)


# 2557 번
# 문제
# 두 숫자 R1과 R2가 있을 때, 두 수의 평균 S는 (R1+R2)/2와 같다.
# 상근이는 정인이 생일 선물로 두 숫자 R1과 R2를 주려고 한다.
# 생일 파티에서 상근이는 정인이에게 이 두 숫자를 말해주고, 정인이는 이 숫자를 받아 적는다.
# 그리고 나서 기쁜 마음으로 1년동안 이 숫자를 외우면서 산다.
# 상근이는 R1과 R2를 엄청난 고민 끝에 정했다.
# 작년에는 R1과 R2를 까먹어서 아무 숫자나 정해서 주었기 때문에,
# 올해는 까먹지 않기 위해서 평균 S도 같이 기억하려고 한다.
# 오늘은 정인이 생일이다.
# 5분 후에 상근이는 생일 선물로 두 숫자 R1과 R2를 말해주어야 하지만,
# 안타깝게도 R2를 까먹고 말았다.
# 하지만 R1과 S는 기억하고 있다!
# 상근이를 도와 R2가 몇 인지 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 두 정수 R1과 S가 주어진다. 두 수는 -1000보다 크거나 같고, 1000보다 작거나 같다.
# 출력
# 첫째 줄에 R2를 출력한다.

R1, S = map(int,input().split())
print(2*S - R1)


# 10699 번
# 문제
# 서울의 오늘 날짜를 출력하는 프로그램을 작성하시오.
# 입력
# 입력은 없다.
# 출력
# 서울의 오늘 날짜를 "YYYY-MM-DD" 형식으로 출력한다.

from datetime import datetime
print(datetime.now().date())


# 7287 번
# 문제
# 자신이 백준 온라인 저지(BOJ)에서 맞은 문제의 수와 아이디를 그대로 출력하는 프로그램을 작성하시오.
# 입력
# 이 문제는 입력이 없다.
# 출력
# 첫 줄에 자신이 맞은 문제의 수, 둘째 줄에 아이디를 출력한다.
print("110\ncatpic")


# 2530 번
# 문제
# KOI 전자에서는 건강에 좋고 맛있는 훈제오리구이 요리를 간편하게 만드는 인공지능 오븐을 개발하려고 한다.
# 인공지능 오븐을 사용하는 방법은 적당한 양의 오리 훈제 재료를 인공지능 오븐에 넣으면 된다.
# 그러면 인공지능 오븐은 오븐구이가 끝나는 시간을 초 단위로 자동적으로 계산한다.
# 또한, KOI 전자의 인공지능 오븐 앞면에는 사용자에게 훈제오리구이 요리가 끝나는 시각을 알려 주는 디지털 시계가 있다.
# 훈제오리구이를 시작하는 시각과 오븐구이를 하는 데 필요한 시간이 초 단위로 주어졌을 때,
# 오븐구이가 끝나는 시각을 계산하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에는 현재 시각이 나온다.
# 현재 시각은 시 A (0 ≤ A ≤ 23), 분 B (0 ≤ B ≤ 59)와 초 C (0 ≤ C ≤ 59)가 정수로
# 빈칸을 사이에 두고 순서대로 주어진다.
# 두 번째 줄에는 요리하는 데 필요한 시간 D (0 ≤ D ≤ 500,000)가 초 단위로 주어진다.
# 출력
# 첫째 줄에 종료되는 시각의 시, 분, 초을 공백을 사이에 두고 출력한다.
# (단, 시는 0부터 23까지의 정수이며, 분, 초는 0부터 59까지의 정수이다.
# 디지털 시계는 23시 59분 59초에서 1초가 지나면 0시 0분 0초가 된다.)

from datetime import *
from random import *
from time import time as time2
from time import sleep
comb = []
timechk1 = []
timechk2 = []
count = 0
while count<10:
    count+=1
    h = randint(0,23)
    m = randint(0,59)
    s = randint(0,59)
    sec = randint(0, 500000)
    comb.append([h,m,s,sec])

    # 풀이 1; 86400으로 시간초 나눠서 풀이
    # h,m,s=map(int,input().split())
    start = time2()
    delta = datetime.combine(date(1,1,1),time(h,m,s))+timedelta(seconds=sec%86400)
    a = str(delta.time()).split(":")
    for i in range(len(a)):
        a[i] = int(a[i])
    # print(*a)
    sleep(0.001)
    timechk1.append(time2()-start)

    # 풀이 2; 입력된 시간초 그대로 풀이
    start = time2()
    # h,m,s=map(int,input().split())
    delta = datetime.combine(date(1,1,1),time(h,m,s))+timedelta(seconds=sec)
    a = str(delta.time()).split(":")
    for i in range(len(a)):
        a[i] = int(a[i])
    # print(*a)
    sleep(0.001)
    timechk2.append(time2() - start)
print(comb)
print(sum(timechk1)/len(timechk1))
print(sum(timechk2)/len(timechk2))


# 2914 번
# 문제
# 창영이는 노래 여러 개를 이어서 부르는 가수이다.
# 유명한 노래의 비슷한 멜로디를 이어서 부르면서
# 언제 곡이 넘어갔는지 모르게 만드는 것이 창영이 노래의 특징이다.
# 이런 노래로 상업적으로 엄청난 성공을 거둔 창영이에게 큰 시련이 찾아왔다.
# 그것은 바로 저작권이었다.
# 창영이의 노래에 포함되어 있는 멜로디는
# 모두 저작권이 다른 사람에게 있는 노래이다.
# 따라서, 이 음악으로 상업적인 활동을 했기 때문에, 저작권 협회에 저작권료를 내야한다.
# 창영이는 자신의 앨범에 포함되어있는 저작권이 있는 멜로디의 평균값을 구해보기로 했다.
# 이 값은 아래와 같이 구할 수 있다.
# (창영이 앨범에 수록된 곡에 포함되어 있는 저작권이 있는 멜로디의 개수) / (앨범에 수록된 곡의 개수)
# 이때, 평균값은 항상 올림을 해서 정수로 만들어야 한다.
# 예를 들어, 창영이의 1집 앨범 "영창에서 영원히 영창피아노를 친다"에 총 38개 곡이 수록되어 있고,
# 이 앨범에 저작권이 있는 멜로디가 894개가 있다면, 평균값은 23.53이 되고 올림해서 24가 된다.
# 매니저 강산이는 얼마나 많은 사람에게 저작권료를 주어야 하는지 궁금해졌다.
# 강산이가 알고 있는 정보는 앨범에 수록되어 있는 곡의 개수와 위에서 구한 평균값이다.
# 이때, 적어도 몇 곡이 저작권이 있는 멜로디인지 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 앨범에 수록된 곡의 개수 A와 평균값 I가 주어진다. (1 ≤ A, I ≤ 100)
# 출력
# 첫째 줄에 적어도 몇 곡이 저작권이 있는 멜로디인지 출력한다.

A, I = map(int,input().split())
print((I-1)*A+1)


# 5355 번
# 문제
# 겨울 방학에 달에 다녀온 상근이는 여름 방학 때는 화성에 갔다 올 예정이다. (3996번)
# 화성에서는 지구와는 조금 다른 연산자 @, %, #을 사용한다.
# @는 3을 곱하고, %는 5를 더하며, #는 7을 빼는 연산자이다.
# 따라서, 화성에서는 수학 식의 가장 앞에 수가 하나 있고, 그 다음에는 연산자가 있다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T가 주어진다.
# 다음 줄에는 화성 수학식이 한 줄에 하나씩 주어진다.
# 입력으로 주어지는 수는 정수이거나 소수 첫째 자리까지 주어지며, 0 이상 100 이하이다.
# 연산자는 최대 3개 주어진다.
# 출력
# 각 테스트 케이스에 대해서, 화성 수학식의 결과를 계산한 다음에, 소수점 둘째 자리까지 출력한다.

def Mars(*calc):
    calc=calc[0]
    num = float(calc[0])
    for i in calc[1:]:
        if i == "@":
            num*=3
        elif i == "%":
            num+=5
        elif i == "#":
            num-=7
    return num

for i in range(int(input())):
    num = Mars(input().split())
    print(f"{num:.2f}")


# 2935 번
# 문제
# 수업 시간에 떠드는 두 학생이 있다.
# 두 학생은 수업에 집중하는 대신에 글로벌 경제 위기에 대해서 토론하고 있었다.
# 토론이 점점 과열되면서 두 학생은 목소리를 높였고, 결국 선생님은 크게 분노하였다.
# 이렇게 학생들이 수업 시간에 떠드는 문제는 어떻게 해결해야 할까?
# 얼마전에 초등학교 선생님으로 취직한 상근이는 이 문제를 수학 문제로 해결한다.
# 학생들을 진정시키기 위해 칠판에 수학 문제를 써주고, 아이들에게 조용히 이 문제를 풀게 한다.
# 학생들이 문제를 금방 풀고 다시 떠드는 것을 방지하기 위해서, 숫자를 매우 크게 한다.
# 아직 초등학교이기 때문에, 학생들은 덧셈과 곱셈만 배웠다.
# 또, 아직 10의 제곱꼴을 제외한 다른 수는 학교에서 배우지 않았기 때문에,
# 선생님이 써주는 수는 모두 10의 제곱 형태이다.
# 쉬는 시간까지 문제를 푸는 것을 막기 위해서, 선생님이 써주는 숫자는 최대 100자리이다.
# 칠판에 쓰여 있는 문제가 주어졌을 때, 결과를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 양의 정수 A가 주어진다.
# 둘째 줄에 연산자 + 또는 *가 주어진다.
# 셋째 줄에 양의 정수 B가 주어진다.
# A와 B는 모두 10의 제곱 형태이고, 길이는 최대 100자리이다.
# 출력
# 첫째 줄에 결과를 출력한다. 결과는 A+B 또는 A*B이며, 입력에서 주어지는 연산자에 의해 결정된다.

from sys import *
input = stdin.readline
A = int(input())
calc = input().strip()
B = int(input())
if calc == "+":
    print(A+B)
else:
    print(A*B)


# 10817 번
# 문제
# 세 정수 A, B, C가 주어진다. 이때, 두 번째로 큰 정수를 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 세 정수 A, B, C가 공백으로 구분되어 주어진다. (1 ≤ A, B, C ≤ 100)
# 출력
# 두 번째로 큰 정수를 출력한다.

# 풀이 1; 리스트 만들고, 정렬 후 출력
bs = list(map(int,input().split()))
bs.sort()
print(bs[1])

# 풀이 2; 정렬된 리스트에서 출력
print(sorted(list(map(int,input().split())))[1])

# 1789 번
# 문제
# 서로 다른 N개의 자연수의 합이 S라고 한다. S를 알 때, 자연수 N의 최댓값은 얼마일까?
# 입력
# 첫째 줄에 자연수 S(1 ≤ S ≤ 4,294,967,295)가 주어진다.
# 출력
# 첫째 줄에 자연수 N의 최댓값을 출력한다.

S=int(input())
N=int((2*S+0.25)**0.5-0.5)
D=S-N*(N+1)/2
if D<=N:
    print(N)
else:
    print(N+1)

# 4101 번
# 문제
# 두 양의 정수가 주어졌을 때, 첫 번째 수가 두 번째 수보다 큰지 구하는 프로그램을 작성하시오.
# 입력
# 입력은 여러 개의 테스트 케이스로 이루어져 있다.
# 각 테스트 케이스는 한 줄로 이루어져 있으며, 두 정수가 주어진다.
# 두 수는 백만보다 작거나 같은 양의 정수이다.
# 입력의 마지막 줄에는 0이 두 개 주어진다.
# 출력
# 각 테스트 케이스마다, 첫 번째 수가 두 번째 수보다 크면 Yes를, 아니면 No를 한 줄에 하나씩 출력한다.
while True:
    a, b = map(int,input().split())
    if a*b == 0:
        break
    if a > b:
        print("Yes")
    else:
        print("No")


# 10156 번
# 문제
# 동수는 제과점에 과자를 사러 가는데 현재 가진 돈이 모자랄 경우 부모님께 모자란 돈을 받으려고 한다.
# 과자 한 개의 가격이 K, 사려고 하는 과자의 개수가 N이고, 현재 가진 돈의 액수를 M이라 할 때
# 여러분은 동수가 부모님께 받아야 하는 모자란 돈을 계산하려고 한다.
# 예를 들어, 과자 한 개의 가격이 30원, 사려고 하는 과자의 개수가 4개, 현재 동수가 가진 돈이 100원이라 할 때,
# 동수가 부모님께 받아야 하는 돈은 20원이다.
# 과자 한 개의 가격이 250원, 사려고 하는 과자의 개수가 2개, 현재 동수가 가진 돈이 140원이라 할 때,
# 동수가 부모님께 받아야 하는 돈은 360원이다.
# 과자 한 개의 가격이 20원, 사려고 하는 과자의 개수가 6개, 현재 동수가 가진 돈이 120원이라 할 때
# 동수가 부모님께 받아야 하는 돈은 0원이다.
# 과자 한 개의 가격이 20원, 사려고 하는 과자의 개수가 10개, 현재 동수가 가진 돈이 320원이라 할 때
# 동수가 부모님께 받아야 하는 돈은 역시 0원이다.
# 과자 한 개의 가격, 사려고 하는 과자의 개수와 동수가 현재 가진 돈의 액수가 주어질 때
# 동수가 부모님께 받아야 하는 돈의 액수를 출력하는 프로그램을 작성하시오.
# 입력
# 첫 번째 줄에는 과자 한 개의 가격 K, 사려고 하는 과자의 개수 N, 현재 동수가 가진 돈 M이 각각 공백을 사이에 두고 주어진다.
# 단, K, N은 1,000 이하의 양의 정수이고, M은 10만 이하의 양의 정수이다. (1 ≤ K, N ≤ 1,000, 1 ≤ M ≤ 100,000이다.)
# 출력
# 첫 줄에 동수가 부모님께 받아야 하는 돈의 액수를 출력한다.

K, N, M = map(int,input().split())
if M >= K*N:
    print(0)
else:
    print(K*N-M)


# 2476 번
# 문제
# 1에서부터 6까지의 눈을 가진 3개의 주사위를 던져서 다음과 같은 규칙에 따라 상금을 받는 게임이 있다.
# 같은 눈이 3개가 나오면 10,000원+(같은 눈)×1,000원의 상금을 받게 된다.
# 같은 눈이 2개만 나오는 경우에는 1,000원+(같은 눈)×100원의 상금을 받게 된다.
# 모두 다른 눈이 나오는 경우에는 (그 중 가장 큰 눈)×100원의 상금을 받게 된다.
# 예를 들어, 3개의 눈 3, 3, 6이 주어지면 상금은 1,000+3×100으로 계산되어 1,300원을 받게 된다.
# 또 3개의 눈이 2, 2, 2로 주어지면 10,000+2×1,000 으로 계산되어 12,000원을 받게 된다.
# 3개의 눈이 6, 2, 5로 주어지면 그 중 가장 큰 값이 6이므로 6×100으로 계산되어 600원을 상금으로 받게 된다.
# N(2 ≤ N ≤ 1,000)명이 주사위 게임에 참여하였을 때, 가장 많은 상금을 받은 사람의 상금을 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에는 참여하는 사람 수 N이 주어지고 그 다음 줄부터 N개의 줄에 사람들이 주사위를 던진 3개의 눈이 빈칸을 사이에 두고 각각 주어진다.
# 출력
# 첫째 줄에 가장 많은 상금을 받은 사람의 상금을 출력한다.

from sys import *
input = stdin.readline
reward = []
for _ in range(int(input())):
    dice = sorted(list(map(int,input().split())))
    if dice.count(dice[1]) == 1:
        reward.append(100*dice[2])
    elif dice.count(dice[1]) == 2:
        reward.append(1000+100*dice[1])
    else:
        reward.append(10000+1000*dice[1])
print(max(reward))


# 2754 번
# 문제
# 어떤 사람의 C언어 성적이 주어졌을 때, 평점은 몇 점인지 출력하는 프로그램을 작성하시오.
# A+: 4.3, A0: 4.0, A-: 3.7
# B+: 3.3, B0: 3.0, B-: 2.7
# C+: 2.3, C0: 2.0, C-: 1.7
# D+: 1.3, D0: 1.0, D-: 0.7
# F: 0.0
# 입력
# 첫째 줄에 C언어 성적이 주어진다. 성적은 문제에서 설명한 13가지 중 하나이다.
# 출력
# 첫째 줄에 C언어 평점을 출력한다.
score={
    "A+": 4.3,
    "A0": 4.0,
    "A-": 3.7,
    "B+": 3.3,
    "B0": 3.0,
    "B-": 2.7,
    "C+": 2.3,
    "C0": 2.0,
    "C-": 1.7,
    "D+": 1.3,
    "D0": 1.0,
    "D-": 0.7,
    "F": 0.0
}
print(score[input()])


# 7567 번
# 문제
# 그릇을 바닥에 놓았을 때 그 높이는 10cm 이다.
# 그런데 두 개의 그릇을 같은 방향으로 포개면 그 높이는 5cm만 증가된다.
# 만일 그릇이 서로 반대방향으로 쌓이면 높이는 그릇만큼, 즉 10cm 늘어난다. 그릇을 괄호 기호로 나타내어 설명해보자.
# 편의상 그릇이 쌓여지는 방향은 왼쪽에서 오른쪽이라고 가정한다.
# 그림에서 ‘(’은 그릇이 바닥에 바로 놓인 상태를 나타내며, ‘)’은 그릇이 거꾸로 놓인 상태를 나타낸다.
# 만일 그릇이 포개진 모양이 ((((와 같다면 전체의 높이는 25cm가 된다.
# 왜냐하면 처음 바닥에 있는 그릇의 높이가 10cm이고 이후 같은 방향으로 3개의 그릇이 포개져 있으므로 늘어난 높이는 5+5+5=15 이기 때문이다.
# ()()와 같은 경우라면 그 높이는 10*4=40cm가 된다.
# 여러분은 입력에 주어진 모양대로 그릇을 쌓을 때 최종의 전체 그릇 높이를 계산해서 출력해야 한다.
# 즉 처음 입력으로 주어진 각 그릇의 방향은 바꿀 수 없다.
# 입력
# 첫 줄에는 괄호문자로만 이루어진 문자열이 주어진다.
# 입력 문자열에서 열린 괄호 ‘(’은 바로 놓인 그릇, 닫힌 괄호 ‘)’은 거꾸로 놓인 그릇을 나타난다.
# 문자열의 길이는 3이상 50 이하이다.
# 출력
# 여러분은 그릇 방향이 괄호 문자로 표시된 문자열을 읽어서 그 최종의 높이를 정수로 출력해야 한다.

def bowl(bowls):
    height = 10
    while len(bowls)>1:
        first = bowls[0]
        comp = bowls[1]
        if first == comp:
            height += 5
        else:
            height += 10
        bowls.remove(bowls[0])
    return height
print(bowl(list(input())))


# 5063 번
# 문제
# 상근이는 TGN사의 사장이다.
# TGN은 Teenager Game Network의 약자 같지만,
# 사실 Temporary Group Name의 약자이다.
# 이 회사는 청소년을 위한 앱을 만드는 회사이다.
# 일년에 걸친 개발기간 끝에 드디어 앱을 완성했고, 이제 팔기만 하면 된다.
# 상근이는 데이트를 인간의 두뇌로 이해할 수 없을 정도로 많이 한다.
# 따라서 엄청난 데이트 비용이 필요하다.
# 상근이는 광고를 적절히 해서 수익을 최대한 올리려고 한다.
# 어느 날 하늘을 바라보던 상근이는 시리우스의 기운을 받게 되었고,
# 광고 효과를 예측하는 능력을 갖게 되었다.
# 광고 효과가 주어졌을 때,
# 광고를 해야할지 말아야할지 결정하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 테스트 케이스의 개수 N이 주어진다.
# 다음 N개의 줄에는 3개의 정수 r, e, c가 주어진다.
# r은 광고를 하지 않았을 때 수익,
# e는 광고를 했을 때의 수익,
# c는 광고 비용이다. (-106 ≤ r,e ≤ 106, 0 ≤ c ≤ 106)
# 출력
# 각 테스트 케이스에 대해서,
# 광고를 해야 하면 "advertise",
# 하지 않아야 하면 "do not advertise",
# 광고를 해도 수익이 차이가 없다면 "does not matter"를 출력한다.

for _ in range(int(input())):
    r, e, c = map(int,input().split())
    if r > e-c:
        print("do not advertise")
    elif r < e-c:
        print("advertise")
    else:
        print("does not matter")



""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """

# 1934 번
# 문제
# 두 자연수 A와 B에 대해서, A의 배수이면서 B의 배수인 자연수를 A와 B의 공배수라고 한다.
# 이런 공배수 중에서 가장 작은 수를 최소공배수라고 한다.
# 예를 들어, 6과 15의 공배수는 30, 60, 90등이 있으며, 최소 공배수는 30이다.
# 두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다.
# 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. (1 ≤ A, B ≤ 45,000)
# 출력
# 첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 입력받은 순서대로 한 줄에 하나씩 출력한다.

# 풀이 1 - 시간 초과, 숫자 리스트를 받아서 1~작은수 로 나누기
for _ in range(int(input())):
    num = sorted(list(map(int,("1 "+input()).split()))) # 리스트 생성
    for i in range(num[1]):
        a=num[1]-i # 제수 = 작은수 ~ 1 사이의 수
        if a == 0: # 제수가 0 일 때 종료
            break
        elif num[1]%a == 0 and num[2]%a == 0: # 두 피제수에 대한 나머지가 0 일 때 값 업데이트
            num[1]/=a
            num[2]/=a
            num[0]*=a
    print(int(num[0]*num[1]*num[2]))

# 풀이 2 - 시간 초과, while을 하나 더 넣어서 값 업데이트 후 break 진행
for _ in range(int(input())):
    num = sorted(list(map(int,("1 "+input()).split()))) # 리스트 생성
    try:
        while True:
            for i in range(num[1]):
                a = num[1] - i  # 제수 = 작은수 ~ 1 사이의 수
                if a == 0:  # 제수가 0 일 때 종료
                    break
                elif num[1] % a == 0 and num[2] % a == 0:  # 두 피제수에 대한 나머지가 0 일 때 값 업데이트
                    num[1] /= a
                    num[2] /= a
                    num[0] *= a
                    break
    except TypeError:
        print(int(num[0]*num[1]*num[2]))

# 풀이 3 - 시간 초과, 역순 한게 문제인 것 같아서 다시 변경
for _ in range(int(input())):
    num = sorted(list(map(int,("1 "+input()).split()))) # 리스트 생성
    try:
        while True:
            x = num[0]
            for i in range(2, int(num[1])+1):
                if num[1] % i == 0 and num[2] % i == 0:  # 두 피제수에 대한 나머지가 0 일 때 값 업데이트
                    num[1] /= i
                    num[2] /= i
                    num[0] *= i
                    break
            if x == num[0]:
                x/0
    except:
        print(int(num[0]*num[1]*num[2]))

# 풀이 4 - 케이스 나눠서 출력
for _ in range(int(input())):
    num = sorted(list(map(int,("1 "+input()).split()))) # 리스트 생성
    if num[2]%num[1] == 0:
        print(num[2])




# 4948 번 - 시간 초과
# 문제
# 베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.
# 이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.
# 예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19)
# 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23)
# 자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오.
# 입력
# 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스는 n을 포함하는 한 줄로 이루어져 있다.
# 입력의 마지막에는 0이 주어진다.
# 출력
# 각 테스트 케이스에 대해서, n보다 크고, 2n보다 작거나 같은 소수의 개수를 출력한다.
# 제한
# 1 ≤ n ≤ 123,456

# 풀이 1
def prime(n):
    if n == 1:
        return 0
    else:
        m = int(n**0.5+1)
        o = 1
        for i in range(2,m):
            if n % i == 0:
                o = 0
                break
        return o

while True:
    n=int(input())
    c=0
    if n==0:break
    if n==1:
        print(1)
        continue
    else:
        # 수정 전: number 의 원소가 범위 내의 모든 수
        # numbers = [i for i in range(n+1, 2*n+1)]
        # 수정 후: numbers 의 원소를 범위 내의 홀수로 제한
        numbers = [2 * i + 1 for i in range(int((n + 1) / 2), n)]
        # 수정 전: map 사용하여 list 생성
        # Prime = list(map(prime,numbers))
        # 수정 후: for 사용하여 list 생성
        Prime = []
        for i in numbers:
            Prime.append(prime(i))
    print(Prime.count(1))

# 2617 번
# 문제
# 모양은 같으나, 무게가 모두 다른 N개의 구슬이 있다. N은 홀수이며, 구슬에는 번호가 1,2,...,N으로 붙어 있다.
# 이 구슬 중에서 무게가 전체의 중간인 (무게 순서로 (N+1)/2번째) 구슬을 찾기 위해서 아래와 같은 일을 하려 한다.
# 우리에게 주어진 것은 양팔 저울이다. 한 쌍의 구슬을 골라서 양팔 저울의 양쪽에 하나씩 올려 보면 어느 쪽이 무거운가를 알 수 있다.
# 이렇게 M개의 쌍을 골라서 각각 양팔 저울에 올려서 어느 것이 무거운가를 모두 알아냈다.
# 이 결과를 이용하여 무게가 중간이 될 가능성이 전혀 없는 구슬들은 먼저 제외한다.
# 예를 들어, N=5이고, M=4 쌍의 구슬에 대해서 어느 쪽이 무거운가를 알아낸 결과가 아래에 있다.
# 구슬 2번이 구슬 1번보다 무겁다.
# 구슬 4번이 구슬 3번보다 무겁다.
# 구슬 5번이 구슬 1번보다 무겁다.
# 구슬 4번이 구슬 2번보다 무겁다.
# 위와 같이 네 개의 결과만을 알고 있으면, 무게가 중간인 구슬을 정확하게 찾을 수는 없지만,
# 1번 구슬과 4번 구슬은 무게가 중간인 구슬이 절대 될 수 없다는 것은 확실히 알 수 있다.
# 1번 구슬보다 무거운 것이 2, 4, 5번 구슬이고, 4번 보다 가벼운 것이 1, 2, 3번이다. 따라서 답은 2개이다.
# M 개의 쌍에 대한 결과를 보고 무게가 중간인 구슬이 될 수 없는 구슬의 개수를 구하는 프로그램을 작성하시오.
# 입력
# 첫 줄은 구슬의 개수를 나타내는 정수 N(1 ≤ N ≤ 99)과 저울에 올려 본 쌍의 개수 M(1 ≤ M ≤ N(N-1)/2)이 주어진다.
# 그 다음 M 개의 줄은 각 줄마다 두 개의 구슬 번호가 주어지는데, 앞 번호의 구슬이 뒤 번호의 구슬보다 무겁다는 것을 뜻한다.
# 출력
# 첫 줄에 무게가 중간이 절대로 될 수 없는 구슬의 수를 출력 한다.

N, M = map(int,input().split())
weight = [[0,0]] * N
for _ in range(M):
    a, b = map(int,input().split())
    i1 = weight[a-1][0] + 1
    i2 = weight[a-1][1]
    j1 = weight[b-1][0]
    j2 = weight[b-1][1] + 1
    weight[a-1] = [i1, i2]
    weight[b-1] = [j1, j2]
    print(f"[{i1}, {i2}], [{j1}, {j2}]")
    print(weight)
print(weight)


# 1759 번 - ?
# 문제
# 바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은,
# 702호에 새로운 보안 시스템을 설치하기로 하였다.
# 이 보안 시스템은 열쇠가 아닌 암호로 동작하게 되어 있는 시스템이다.
# 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며
# 최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다.
# 또한 정렬된 문자열을 선호하는 조교들의 성향으로 미루어 보아
# 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측된다.
# 즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다.
# 새 보안 시스템에서 조교들이 암호로 사용했을 법한 문자의 종류는 C가지가 있다고 한다.
# 이 알파벳을 입수한 민식, 영식 형제는 조교들의 방에 침투하기 위해 암호를 추측해 보려고 한다.
# C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 두 정수 L, C가 주어진다. (3 ≤ L ≤ C ≤ 15)
# 다음 줄에는 C개의 문자들이 공백으로 구분되어 주어진다.
# 주어지는 문자들은 알파벳 소문자이며, 중복되는 것은 없다.
# 출력
# 각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력한다.

L, C = map(int,input().split())
password = set(map(str,input().split()))
vowel = {"a", "e", "i", "o", "u"}
v_in_p = password.intersection(vowel)


# 25192 번 - 시간 초과
# 문제
# 알고리즘 입문방 오픈 채팅방에서는 새로운 분들이 입장을 할 때마다 곰곰티콘을 사용해 인사를 한다. 이를 본 문자열 킬러 임스는 채팅방의 기록을 수집해 그 중 곰곰티콘이 사용된 횟수를 구해 보기로 했다.
# ENTER는 새로운 사람이 채팅방에 입장했음을 나타낸다. 그 외는 채팅을 입력한 유저의 닉네임을 나타낸다. 닉네임은 숫자 또는 영문 대소문자로 구성되어 있다.
# 새로운 사람이 입장한 이후 처음 채팅을 입력하는 사람은 반드시 곰곰티콘으로 인사를 한다. 그 외의 기록은 곰곰티콘을 쓰지 않은 평범한 채팅 기록이다.
# 채팅 기록 중 곰곰티콘이 사용된 횟수를 구해보자!
# 입력
# 첫 번째 줄에는 채팅방의 기록 수를 나타내는 정수 N 이 주어진다. (1 <= N <= 100,000)
# 두 번째 줄부터 N 개의 줄에 걸쳐 새로운 사람의 입장을 나타내는 ENTER, 혹은 채팅을 입력한 유저의 닉네임이 문자열로 주어진다. (1 <= 문자열 길이 <= 20)
# 첫 번째 주어지는 문자열은 무조건 ENTER이다.
# 출력
# 채팅 기록 중 곰곰티콘이 사용된 횟수를 출력하시오.

# 풀이 1
count = 0 # 횟수 체크 변수 선언
for _ in range(int(input())):
    log = input()
    if log == "ENTER": # 채팅 로그가 "입장"이면 채팅 로그 리스트 초기화
        gomgom = []
    elif log not in gomgom: # 채팅 로그 리스트 내에 닉네임이 없을 경우 닉네임 삽입하고, 곰곰티콘 횟수 1회 증가
        gomgom.append(log)
        count += 1
print(count)


# 11653 번 - 시간 초과
# 문제
# 정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.
# 출력
# N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.

# 풀이 1 - 소수를 먼저 입력해 놓고 나누기, 시간 초과
primenumber = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
               101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,
               211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,
               307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,
               401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,
               503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,
               601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,
               701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,
               809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,
               907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
N = int(input())
while N>1:
    for i in primenumber:
        if N % i == 0:
            print(i)
            N /= i
            break

# 풀이 2 - N 이하의 소수를 구하고 소인수분해 하기, 시간 초과
def prime(n):
    if n == 1:
        return 0
    else:
        m = int(n**0.5+1)
        for i in range(2,m):
            if n % i == 0:
                n = 0
                break
        return n

N = int(input())
N_list = [i for i in range(N+1)]
M_list = list(set(map(prime,N_list)))
M_list.sort()
if 0 in M_list:
    M_list.remove(0)
while N>1:
    for i in M_list:
        if N % i == 0:
            print(i)
            N /= i
            break
        else:
            M_list.remove(i)

















# 10815 번 - 시간 초과
# 문제
# 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다.
# 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 두 숫자 카드에 같은 수가 적혀있는 경우는 없다.
# 셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다.
# 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다.
# 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다
# 출력
# 첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.

# 시간 초과
from sys import stdin
N = int(stdin.readline())
N_list=list(map(int,stdin.readline().split()))
M = int(stdin.readline())
M_list=list(map(int,stdin.readline().split()))
C_list=[]
for i in M_list:
    if i in N_list:
        C_list.append(1)
    else:
        C_list.append(0)
print(C_list)

# 런타임 에러, 외부 lib 없음
from sys import stdin
import pandas as pd
N = int(stdin.readline())
N_df=pd.DataFrame(map(int,stdin.readline().split()),columns=["N"])
M = int(stdin.readline())
M_df=pd.DataFrame(map(int,stdin.readline().split()),columns=["M"])
Filter = M_df["M"].isin(N_df["N"])
M_df.loc[Filter, "M"] = 1
M_df.loc[-Filter, "M"] = 0
print(" ".join(list(M_df["M"])))


# 2004 번 - 시간 초과
# 문제
# binom{n}{m}의 끝자리 $0$의 개수를 출력하는 프로그램을 작성하시오
# 입력
# 첫째 줄에 정수 n, m (0 ≤ m ≤ n ≤ 2,000,000,000, n != 0 )이 들어온다.
# 출력
# 첫째 줄에 binom{n}{m}의 끝자리 0의 개수를 출력한다.

# 시간 초과
from math import factorial
n, m = map(int,input().split())
n_m = int(factorial(n)//(factorial(m)*factorial(n-m)))
count = 0
while n_m%10==0:
    n_m//=10
    count+=1
print(count)

# 시간 초과
from math import factorial
n, m = map(int,input().split())
n_m = list(str(int(factorial(n)//(factorial(m)*factorial(n-m)))))
n_m.reverse()
count = 0
for i in n_m:
    if i=="0":
        count+=1
    else:
        break
print(count)

# 시간 초과
from sys import stdin
from math import factorial
n, m = map(int,stdin.readline().split())
n_m = list(str(int(factorial(n)//(factorial(m)*factorial(n-m)))))
n_m.reverse()
count = 0
for i in n_m:
    if i=="0":
        count+=1
    else:
        break
print(count)

# 시간 초과
from math import factorial
n, m = map(int,input().split())
n_m = list(str(int(factorial(n)//(factorial(m)*factorial(n-m)))))
n_m.reverse()
count = len(n_m)
for i in range(1,10):
    count=min(0, n_m.index(i))
print(count)


# 10757 번 - C 언어 문제
# 문제
# 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 A와 B가 주어진다. (0 < A,B < 10**10000)
# 출력
# 첫째 줄에 A+B를 출력한다.
import sys
a,b=map(int,sys.stdin.readline().split())
print(a+b)



"""
# 풀이 1 - 시간 초과
def fibonacci(n, listing):
    if n == 0:
        listing.append(n)
        return 0, listing
    elif n == 1:
        listing.append(n)
        return 1, listing
    else:
        return fibonacci(n-1, listing) + fibonacci(n-2, listing)

for i in range(int(input())):
    count = []
    fibonacci(int(input()),count)
    print(count.count(0), count.count(1))

# 풀이 2
def fibonacci(n):
    if n == 0:
        f_list.append(0)
        return 0
    elif n == 1:
        f_list.append(1)
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
global f_list
f_list = []
fibonacci(6)
print(f_list)
"""




"""
시간 측정 모델
from time import time
start = time()



print("#######end#######")
print(time()-start)
"""

"""
파이참 편집 기능
# 찾아서 바꾸기
편집할 부분을 블럭으로 씌운 다음에 Ctrl + R 로 특정 문자를 바꿈

# 위 아래 코드와 줄바꿈
해당 열에 커서를 놓고 Alt + Shift + 방향키

# 동일 위치 열 편집
Ctrl + Ctrl + 방향키

# 다중 커서 편집
Alt + 클릭
"""