

# 2592 번
# 문제
# 어떤 수들이 있을 때, 그 수들을 대표하는 값으로 가장 흔하게 쓰이는 것은 평균이다.
# 평균은 주어진 모든 수의 합을 수의 개수로 나눈 것이다.
# 예를 들어 10, 40, 30, 60, 30, 20, 60, 30, 40, 50의 평균은
# (10 + 40 + 30 + 60 + 30 + 20 + 60 + 30 + 40 + 50) / 10 = 370 / 10 = 37이 된다.
# 평균 이외의 또 다른 대표값으로 최빈값이라는 것이 있다.
# 최빈값은 주어진 수들 가운데 가장 많이 나타나는 수이다.
# 예를 들어 10, 40, 30, 60, 30, 20, 60, 30, 40, 50이 주어질 경우,
# 30이 세 번, 40과 60이 각각 두 번, 10, 20, 50이 각각 한 번씩 나오므로, 최빈값은 30이 된다.
# 열 개의 자연수가 주어질 때 이들의 평균과 최빈값을 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄부터 열 번째 줄까지 한 줄에 하나씩 자연수가 주어진다.
# 주어지는 자연수는 1,000 보다 작은 10의 배수이다.
# 출력
# 첫째 줄에는 평균을 출력하고, 둘째 줄에는 최빈값을 출력한다.
# 최빈값이 둘 이상일 경우 그 중 하나만 출력한다.
# 평균과 최빈값은 모두 자연수이다.

nums = []
for _ in range(10):
    nums.append(int(input()))
nums_dic = {}
for i in nums:
    try:
        nums_dic[i]+=1
    except:
        nums_dic[i]=1
print(f"{int(sum(nums)/len(nums))}\n{max(nums_dic,key=nums_dic.get)}")


# 2711 번
# 문제
# 고창영은 맨날 오타를 낸다.
# 창영이가 오타를 낸 문장과 오타를 낸 위치가 주어졌을 때,
# 오타를 지운 문자열을 출력하는 프로그램을 작성하시오.
# 창영이는 오타를 반드시 1개만 낸다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T(1<=T<=1,000)가 주어진다.
# 각 테스트 케이스는 한 줄로 구성되어 있다.
# 첫 숫자는 창영이가 오타를 낸 위치이고,
# 두 번째 문자열은 창영이가 친 문자열이다.
# 문자열의 가장 첫 문자는 1번째 문자이고,
# 문자열의 길이는 80을 넘지 않고, 대문자로만 이루어져 있다.
# 오타를 낸 위치는 문자열 길이보다 작거나 같다.
# 출력
# 각 테스트 케이스에 대해 오타를 지운 문자열을 출력한다.
for _ in range(int(input())):
    a, b = input().split()
    b_list = list(b)
    b_list.pop(int(a) - 1)
    print("".join(b_list))
    # print(b.remove(int(a)))


# 2953 번
# 문제
# "나는 요리사다"는 다섯 참가자들이 서로의 요리 실력을 뽐내는 티비 프로이다.
# 각 참가자는 자신있는 음식을 하나씩 만들어오고, 서로 다른 사람의 음식을 점수로 평가해준다.
# 점수는 1점부터 5점까지 있다.
# 각 참가자가 얻은 점수는 다른 사람이 평가해 준 점수의 합이다.
# 이 쇼의 우승자는 가장 많은 점수를 얻은 사람이 된다.
# 각 참가자가 얻은 평가 점수가 주어졌을 때, 우승자와 그의 점수를 구하는 프로그램을 작성하시오.
# 입력
# 총 다섯 개 줄에 각 참가자가 얻은 네 개의 평가 점수가 공백으로 구분되어 주어진다.
# 첫 번째 참가자부터 다섯 번째 참가자까지 순서대로 주어진다. 항상 우승자가 유일한 경우만 입력으로 주어진다.
# 출력
# 첫째 줄에 우승자의 번호와 그가 얻은 점수를 출력한다.

# 풀이 1 - list 사용
score=[0]*5
index = 1
max_score = 0
for i in range(5):
    score[i] = list(map(int,input().split()))
    if i == 0:
        max_score = sum(score[i])
    else:
        if sum(score[i]) > max_score:
            max_score = sum(score[i])
            index=i+1
print(index, max_score)

# 풀이 2 -  dict 사용
score={}
for i in range(5):
    score[i+1]=sum(list(map(int,input().split())))
max_ = max(score,key=score.get)
print(max_, score[max_])


# 1292 번
# 문제
# 동호는 내년에 초등학교를 입학한다.
# 그래서 동호 어머니는 수학 선행 학습을 위해 쉽게 푸는 문제를 동호에게 주었다.
# 이 문제는 다음과 같다.
# 1을 한 번, 2를 두 번, 3을 세 번, 이런 식으로 1 2 2 3 3 3 4 4 4 4 5 ..
# 이러한 수열을 만들고 어느 일정한 구간을 주면 그 구간의 합을 구하는 것이다.
# 하지만 동호는 현재 더 어려운 문제를 푸느라 바쁘기에 우리가 동호를 도와주자.
# 입력
# 첫째 줄에 구간의 시작과 끝을 나타내는 정수 A, B(1 ≤ A ≤ B ≤ 1,000)가 주어진다.
# 즉, 수열에서 A번째 숫자부터 B번째 숫자까지 합을 구하면 된다.
# 출력
# 첫 줄에 구간에 속하는 숫자의 합을 출력한다.

a, b = map(int,input().split())
an = int(1/2+(2*a)**0.5) # a가 속해있는 군
al = a-an*(an-1)/2
sum_an_1 = an*(an-1)*(2*an-1)/6 + al*an
bn = int(1/2+(2*b)**0.5) # b가 속해있는 군
bl = b-bn*(bn-1)/2
sum_bn_1 = bn*(bn-1)*(2*bn-1)/6 + bl*bn
print(int(sum_bn_1-sum_an_1+an))


# 3460 번
# 문제
# 양의 정수 n이 주어졌을 때, 이를 이진수로 나타냈을 때 1의 위치를 모두 찾는 프로그램을 작성하시오.
# 최하위 비트(least significant bit, lsb)의 위치는 0이다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T가 주어진다.
# 각 테스트 케이스는 한 줄로 이루어져 있고, n이 주어진다. (1 ≤ T ≤ 10, 1 ≤ n ≤ 10**6)
# 출력
# 각 테스트 케이스에 대해서, 1의 위치를 공백으로 구분해서 줄 하나에 출력한다. 위치가 낮은 것부터 출력한다.

bin = [2**x for x in range(20)]
bin.reverse()
for _ in range(int(input())):
    n = int(input())
    binary = []
    bin_fin=[]
    for i in bin:
        binary.append(n//i)
        n%=i
    binary.reverse()
    bin_fin = [x for x in range(len(binary)) if binary[x]==1]
    print(*bin_fin)


# 10807 번
# 문제
# 총 N개의 정수가 주어졌을 때, 정수 v가 몇 개인지 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 정수의 개수 N(1 ≤ N ≤ 100)이 주어진다.
# 둘째 줄에는 정수가 공백으로 구분되어져있다.
# 셋째 줄에는 찾으려고 하는 정수 v가 주어진다.
# 입력으로 주어지는 정수와 v는 -100보다 크거나 같으며, 100보다 작거나 같다.
# 출력
# 첫째 줄에 입력으로 주어진 N개의 정수 중에 v가 몇 개인지 출력한다.

N=[0]*int(input())
N=input().split()
print(N.count(input()))


# 2822 번
# 문제
# 상근이는 퀴즈쇼의 PD이다. 이 퀴즈쇼의 참가자는 총 8개 문제를 푼다.
# 참가자는 각 문제를 풀고, 그 문제를 풀었을 때 얻는 점수는 문제를 풀기 시작한 시간부터 경과한 시간과 난이도로 결정한다.
# 문제를 풀지 못한 경우에는 0점을 받는다.
# 참가자의 총 점수는 가장 높은 점수 5개의 합이다.
# 상근이는 잠시 여자친구와 전화 통화를 하느라 참가자의 점수를 계산하지 않고 있었다.
# 참가자의 8개 문제 점수가 주어졌을 때, 총 점수를 구하는 프로그램을 작성하시오.
# 입력
# 8개 줄에 걸쳐서 각 문제에 대한 참가자의 점수가 주어진다.
# 점수는 0보다 크거나 같고, 150보다 작거나 같다. 모든 문제에 대한 점수는 서로 다르다.
# 입력으로 주어지는 순서대로 1번 문제, 2번 문제, ... 8번 문제이다.
# 출력
# 첫째 줄에 참가자의 총점을 출력한다. 둘째 줄에는 어떤 문제가 최종 점수에 포함되는지를 공백으로 구분하여 출력한다. 출력은 문제 번호가 증가하는 순서이어야 한다.

score = [0]*8
for i in range(8):
    score[i] = int(input())
sort_score = score.copy()
sort_score.sort(reverse=True)
print(sum(sort_score[:5]))
idx = [score.index(x)+1 for x in sort_score[:5]]
print(*sorted(idx))


# 5054 번
# 문제
# 선영이는 쇼핑하러 긴 도로에 자주 간다.
# 선영이는 주차를 세상에서 가장 귀찮아 하기 때문에, 아무데나 주차를 한다.
# 주차를 한 후에는 가려고 했던 상점으로 걸어 간다.
# 어느 날, 선영이는 다리가 너무 아파서 병원에 갔다.
# 의사는 선영이에게 되도록 조금 걷거나, 쇼핑을 하지 말라고 했다.
# 선영이는 쇼핑을 버릴 수 없다. 그녀의 특기를 발휘해서 가장 좋은 주차 자리를 찾으려고 한다.
# 긴 도로는 일직선이다. 또, 모든 상점의 위치는 정수 좌표를 가지고 있다.
# 주차장은 모든 정수 좌표마다 하나씩 있으며, 선영이를 위해 항상 비어있다.
# 선영이는 주차비를 아끼기 위해서 쇼핑을 마치기 전 까지는 주차한 차를 이동시키지 않을 것이다.
# 선영이는 힘이 매우 세기 때문에, 자신이 쇼핑한 물건을 모두 들지 못하는 경우는 없다.
# 가려고 계획한 상점은 모두 방문해야 한다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 t가 주어진다. (1 ≤ t ≤ 100)
# 모든 테스트 케이스는 두 줄로 이루어져 있다.
# 첫째 줄에는 선영이가 방문할 상점의 수 n이 주어지며 (1 ≤ n ≤ 20),
# 둘째 줄에는 상점의 위치가 주어진다. (0 ≤ xi ≤ 99)
# 출력
# 선영이가 가려고 했던 모든 상점을 방문하고 차로 돌아오기 위해 걸어야 하는 거리의 최솟값을 출력한다.

for _ in range(int(input())):
    shop = [0]*int(input())
    shop = list(map(int,input().split()))
    print(2*(max(shop)-min(shop)))


# 2752 번
# 문제
# 동규는 세수를 하다가 정렬이 하고싶어졌다.
# 숫자 세 개를 생각한 뒤에, 이를 오름차순으로 정렬하고 싶어 졌다.
# 숫자 세 개가 주어졌을 때, 가장 작은 수, 그 다음 수, 가장 큰 수를 출력하는 프로그램을 작성하시오.
# 입력
# 숫자 세 개가 주어진다. 이 숫자는 1보다 크거나 같고, 1,000,000보다 작거나 같다. 이 숫자는 모두 다르다.
# 출력
# 제일 작은 수, 그 다음 수, 제일 큰 수를 차례대로 출력한다.

print(*sorted(list(map(int,input().split()))))


# 5543 번
# 문제
# 상근날드에서 가장 잘 팔리는 메뉴는 세트 메뉴이다.
# 주문할 때, 자신이 원하는 햄버거와 음료를 하나씩 골라,
# 세트로 구매하면, 가격의 합계에서 50원을 뺀 가격이 세트 메뉴의 가격이 된다.
# 햄버거는 총 3종류 상덕버거, 중덕버거, 하덕버거가 있고, 음료는 콜라와 사이다 두 종류가 있다.
# 햄버거와 음료의 가격이 주어졌을 때, 가장 싼 세트 메뉴의 가격을 출력하는 프로그램을 작성하시오.
# 입력
# 입력은 총 다섯 줄이다.
# 첫째 줄에는 상덕버거, 둘째 줄에는 중덕버거, 셋째 줄에는 하덕버거의 가격이 주어진다.
# 넷째 줄에는 콜라의 가격, 다섯째 줄에는 사이다의 가격이 주어진다.
# 모든 가격은 100원 이상, 2000원 이하이다.
# 출력
# 첫째 줄에 가장 싼 세트 메뉴의 가격을 출력한다.

hamberger=[]
drink=[]
for _ in range(3):
    hamberger.append(int(input()))
for _ in range(2):
    drink.append(int(input()))
print(min(hamberger)+min(drink)-50)


# 2587 번
# 문제
# 어떤 수들이 있을 때, 그 수들을 대표하는 값으로 가장 흔하게 쓰이는 것은 평균이다.
# 평균은 주어진 모든 수의 합을 수의 개수로 나눈 것이다.
# 예를 들어 10, 40, 30, 60, 30의 평균은 (10 + 40 + 30 + 60 + 30) / 5 = 170 / 5 = 34가 된다.
# 평균 이외의 또 다른 대표값으로 중앙값이라는 것이 있다.
# 중앙값은 주어진 수를 크기 순서대로 늘어 놓았을 때 가장 중앙에 놓인 값이다.
# 예를 들어 10, 40, 30, 60, 30의 경우, 크기 순서대로 늘어 놓으면
# 10 30 30 40 60
# 이 되고 따라서 중앙값은 30이 된다.
# 다섯 개의 자연수가 주어질 때 이들의 평균과 중앙값을 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄부터 다섯 번째 줄까지 한 줄에 하나씩 자연수가 주어진다.
# 주어지는 자연수는 100 보다 작은 10의 배수이다.
# 출력
# 첫째 줄에는 평균을 출력하고, 둘째 줄에는 중앙값을 출력한다.
# 평균과 중앙값은 모두 자연수이다.

nums=[0]*5
for _ in range(5):
    nums[_]=int(input())
print(f"{int(sum(nums)/len(nums))}\n{sorted(nums)[2]}")


# 1427 번
# 문제
# 배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자.
# 입력
# 첫째 줄에 정렬하려고 하는 수 N이 주어진다.
# N은 1,000,000,000보다 작거나 같은 자연수이다.
# 출력
# 첫째 줄에 자리수를 내림차순으로 정렬한 수를 출력한다.

a = list(input())
a.sort(reverse=True)
print("".join(a))


# 2309 번
# 문제
# 왕비를 피해 일곱 난쟁이들과 함께 평화롭게 생활하고 있던 백설공주에게 위기가 찾아왔다.
# 일과를 마치고 돌아온 난쟁이가 일곱 명이 아닌 아홉 명이었던 것이다.
# 아홉 명의 난쟁이는 모두 자신이 "백설 공주와 일곱 난쟁이"의 주인공이라고 주장했다.
# 뛰어난 수학적 직관력을 가지고 있던 백설공주는, 다행스럽게도 일곱 난쟁이의 키의 합이 100이 됨을 기억해 냈다.
# 아홉 난쟁이의 키가 주어졌을 때, 백설공주를 도와 일곱 난쟁이를 찾는 프로그램을 작성하시오.
# 입력
# 아홉 개의 줄에 걸쳐 난쟁이들의 키가 주어진다.
# 주어지는 키는 100을 넘지 않는 자연수이며, 아홉 난쟁이의 키는 모두 다르며, 가능한 정답이 여러 가지인 경우에는 아무거나 출력한다.
# 출력
# 일곱 난쟁이의 키를 오름차순으로 출력한다. 일곱 난쟁이를 찾을 수 없는 경우는 없다.

# 풀이 1 - intertools.combination 사용
from itertools import *
drf = [0]*9
for _ in range(9):
    drf[_] = int(input())
for i in combinations(drf,7):
    if sum(i) == 100:
        for j in sorted(list(i)):
            print(j)
        break

# 풀이 2
drf = sorted([int(input()) for _ in range(9)]) # 입력 받음
fakedrf = sum(drf) - 100 # 가짜 난쟁이 키의 합
for i in drf:
    drf_mirror = drf.copy()
    drf_mirror.remove(i)
    for j in drf_mirror:
        if i+j == fakedrf:
            break
    if i + j == fakedrf:
        drf.remove(i)
        drf.remove(j)
        break
for i in drf:
    print(i)


# 9076 번
# 문제
# 한국 체조협회에서는 심판의 오심을 막기 위하여 점수 집계 시스템을 고치기로 하였다.
# 이전에는 5명의 심판이 1점부터 10점까지 정수의 점수를 주면 최고점과 최저점을 하나씩 제외한 점수의 합을 총점으로 하였다.
# 이를 보완하기 위해서 최고점과 최저점을 뺀 나머지 3명 점수의 최고점과 최저점의 차이가 4점 이상 나게 되면 점수 조정을 거쳐서 다시 점수를 매기려고 한다.
# 점수를 집계하여 총점을 계산하거나, 점수 조정을 거쳐서 다시 점수를 매기려고 하는 경우에는 총점 대신 KIN(Keep In Negotiation)을 출력하는 프로그램을 작성하시오.
# 입력
# 입력의 첫 줄에는 테스트 케이스의 개수 T(1 ≤ T ≤ 10)가 주어진다.
# 각 테스트 케이스는 한 줄에 다섯 심판이 준 점수 다섯 개의 정수 Ni(1 ≤ Ni ≤ 10, i = 1, 2, ..., 5)가 하나의 공백을 사이에 두고 주어진다.
# 출력
# 각 테스트 케이스에 대해서 총점을 한 줄씩 출력한다.
# 만일 점수 조정을 거쳐서 다시 점수를 매기려고 하는 경우에는 총점 대신 KIN을 출력한다.

for _ in range(int(input())):
    score = list(map(int,input().split()))
    score.remove(max(score))
    score.remove(min(score))
    if abs(max(score)-min(score))>3:
        print("KIN")
    else:
        print(sum(score))


# 2693 번
# 문제
# 배열 A가 주어졌을 때, N번째 큰 값을 출력하는 프로그램을 작성하시오.
# 배열 A의 크기는 항상 10이고, 자연수만 가지고 있다. N은 항상 3이다.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다.
# 각 테스트 케이스는 한 줄로 이루어져 있고, 배열 A의 원소 10개가 공백으로 구분되어 주어진다.
# 이 원소는 1보다 크거나 같고, 1,000보다 작거나 같은 자연수이다.
# 출력
# 각 테스트 케이스에 대해 한 줄에 하나씩 배열 A에서 3번째 큰 값을 출력한다.

for _ in range(int(input())):
    print(sorted(list(map(int,input().split())))[-3])


# 5176 번
# 문제
# 이번 ACM-ICPC 대회의 자리는 참가자들이 직접 정한다.
# 참가자들은 예비 소집일에 자신이 원하는 자리를 미리 정해놓았고, 대회 당일에 어제 적어놓은 자리에 앉으면 된다.
# 여러명이 같은 자리를 적어논 경우에는, 먼저 도착한 사람이 그 자리에 앉게되고, 앉지 못한 사람은 대회에 참가할 수 없다.
# 각 사람이 선호하는 자리가 주어졌을 때, 대회에 참가하지 못하는 사람의 수를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 테스트 케이스의 개수 K가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어 있다.
# 첫째 줄에 참가자의 수 P와 자리의 수 M이 주어진다. (1 ≤ P, M ≤ 500)
# 다음 P개 줄에는 각 참가자가 원하는 자리가 주어진다.
# 자리는 1번부터 M번까지 있다.
# 입력으로 주어지는 참가자가 도착하는 순서이다.
# 출력
# 각 테스트 케이스에 대해서, 대회에 참가하지 못하는 사람의 수를 출력한다.

for _ in range(int(input())):
    seat={}
    loose = 0
    P, M = map(int,input().split())
    for i in range(P):
        m = int(input())
        try:
            if seat[m]:
                loose+=1
        except:
            seat[m] = i+1
    print(loose)


# 10773 번
# 문제
# 나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.
# 재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.
# 재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.
# 재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!
# 입력
# 첫 번째 줄에 정수 K가 주어진다. (1 ≤ K ≤ 100,000)
# 이후 K개의 줄에 정수가 1개씩 주어진다.
# 정수는 0에서 1,000,000 사이의 값을 가지며, 정수가 "0" 일 경우에는 가장 최근에 쓴 수를 지우고, 아닐 경우 해당 수를 쓴다.
# 정수가 "0"일 경우에 지울 수 있는 수가 있음을 보장할 수 있다.
# 출력
# 재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 2**31-1보다 작거나 같은 정수이다.

# from sys import * # 쓰면 116ms, 안 쓰면 4004ms
# input = stdin.readline
money = []
for _ in range(int(input())):
    m = int(input())
    if m != 0:
        money.append(m)
    else:
        money.pop(-1)
print(sum(money))


# 3040 번
# 문제
# 매일 매일 일곱 난쟁이는 광산으로 일을 하러 간다. 난
# 쟁이가 일을 하는 동안 백설공주는 그들을 위해 저녁 식사를 준비한다.
# 백설공주는 의자 일곱개, 접시 일곱개, 나이프 일곱개를 준비한다.
# 어느 날 광산에서 아홉 난쟁이가 돌아왔다.
# (왜 그리고 어떻게 아홉 난쟁이가 돌아왔는지는 아무도 모른다)
# 아홉 난쟁이는 각각 자신이 백설공주의 일곱 난쟁이라고 우기고 있다.
# 백설공주는 이런 일이 생길 것을 대비해서, 난쟁이가 쓰고 다니는 모자에 100보다 작은 양의 정수를 적어 놓았다.
# 사실 백설 공주는 공주가 되기 전에 매우 유명한 수학자였다.
# 따라서, 일곱 난쟁이의 모자에 쓰여 있는 숫자의 합이 100이 되도록 적어 놓았다.
# 아홉 난쟁이의 모자에 쓰여 있는 수가 주어졌을 때, 일곱 난쟁이를 찾는 프로그램을 작성하시오.
# (아홉 개의 수 중 합이 100이 되는 일곱 개의 수를 찾으시오)
# 입력
# 총 아홉개 줄에 1보다 크거나 같고 99보다 작거나 같은 자연수가 주어진다.
# 모든 숫자는 서로 다르다. 또, 항상 답이 유일한 경우만 입력으로 주어진다.
# 출력
# 일곱 난쟁이가 쓴 모자에 쓰여 있는 수를 한 줄에 하나씩 출력한다.

from itertools import *
drf = [0]*9
for _ in range(9):
    drf[_] = int(input())
for i in combinations(drf,7):
    if sum(i) == 100:
        for j in sorted(list(i)):
            print(j)
        break


# 3058 번
# 문제
# 7개의 자연수가 주어질 때, 이들 중 짝수인 자연수들을 모두 골라 그 합을 구하고,
# 고른 짝수들 중 최솟값을 찾는 프로그램을 작성하시오.
# 예를 들어, 7개의 자연수 13, 78, 39, 42, 54, 93, 86가 주어지면
# 이들 중 짝수는 78, 42, 54, 86이므로 그 합은 78 + 42 + 54 + 86 = 260 이 되고,
# 42 < 54 < 78 < 86 이므로 짝수들 중 최솟값은 42가 된다.
# 입력
# 입력은 T개의 테스트 데이터로 구성된다.
# 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다.
# 각 테스트 데이터는 한 줄로 구성되어 있고, 7개의 자연수가 공백으로 구분되어 있다.
# 입력으로 주어지는 자연수는 1보다 크거나 같고, 100보다 작거나 같다.
# 7개의 자연수 중 적어도 하나는 짝수이다.
# 출력
# 각 테스트 데이터에 대해, 7개 자연수 중 짝수의 합과 최솟값을 공백으로 구분하여 한 줄에 하나씩 출력한다.

for _ in range(int(input())):
    nums = list(map(int,input().split()))
    even_nums = [x for x in nums if x%2 ==0]
    print(f"{sum(even_nums)} {min(even_nums)}")


# 5800 번
# 문제
# 한상덕은 이번에 중덕 고등학교에 새로 부임한 교장 선생님이다.
# 교장 선생님으로서 첫 번째 일은 각 반의 수학 시험 성적의 통계를 내는 일이다.
# 중덕 고등학교 각 반의 학생들의 수학 시험 성적이 주어졌을 때,
# 최대 점수, 최소 점수, 점수 차이를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 중덕 고등학교에 있는 반의 수 K (1 ≤ K ≤ 100)가 주어진다.
# 다음 K개 줄에는 각 반의 학생수 N (2 ≤ N ≤ 50)과 각 학생의 수학 성적이 주어진다.
# 시험 성적은 0보다 크거나 같고, 100보다 작거나 같은 정수이고, 공백으로 나누어져 있다.
# 출력
# 각 반에 대한 출력은 다음과 같이 두 줄로 이루어져 있다.
# 첫째 줄에는 "Class X"를 출력한다. X는 반의 번호이며 입력으로 주어진 순서대로 1부터 증가한다.
# 둘째 줄에는 가장 높은 점수, 낮은 점수, 성적을 내림차순으로 정렬했을 때 가장 큰 인접한 점수 차이를 예제 출력과 같은 형식으로 출력한다.

for i in range(int(input())):
    score = list(map(int,input().split()))
    stud = score[0]
    score = sorted(score[1:])
    gap=0
    for j in range(1,len(score)):
        j_=score[j]-score[j-1]
        if j_>gap:
            gap=j_
    print(f"Class {i+1}\nMax {max(score)}, Min {min(score)}, Largest gap {gap}")


# 5576 번
# 문제
# 최근 온라인에서의 프로그래밍 콘테스트가 열렸다.
# W 대학과 K 대학의 컴퓨터 클럽은 이전부터 라이벌 관계에있어,
# 이 콘테스트를 이용하여 양자의 우열을 정하자라는 것이되었다.
# 이번이 두 대학에서 모두 10 명씩이 콘테스트에 참여했다.
# 긴 논의 끝에 참가한 10 명 중 득점이 높은 사람에서 3 명의 점수를 합산하여 대학의 득점으로하기로 했다.
# W 대학 및 K 대학 참가자의 점수 데이터가 주어진다.
# 이때, 각각의 대학의 점수를 계산하는 프로그램을 작성하라.
# 입력
# 입력은 20 행으로 구성된다.
# 1 번째 줄부터 10 번째 줄에는 W 대학의 각 참가자의 점수를 나타내는 정수가
# 11 번째 줄부터 20 번째 줄에는 K 대학의 각 참가자의 점수를 나타내는 정수가 적혀있다.
# 이 정수는 모두 0 이상 100 이하이다.
# 출력
# W 대학 점수와 K 대학의 점수를 순서대로 공백으로 구분하여 출력하라.

W = sorted([int(input()) for _ in range(10)])
K = sorted([int(input()) for _ in range(10)])
print(f"{sum(W[-3:])} {sum(K[-3:])}")


# 11047 번
# 문제
# 준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.
# 동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다.
# 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)
# 둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다.
# (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)
# 출력
# 첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.

N, K = map(int,input().split())
coin = sorted([int(input()) for i in range(N)],reverse=True)
cnt = 0
for i in coin:
    if K//i>0:
        cnt+=K//i
        K%=i
print(cnt)


# 2743 번
# 문제
# 알파벳으로만 이루어진 단어를 입력받아, 그 길이를 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 영어 소문자와 대문자로만 이루어진 단어가 주어진다. 단어의 길이는 최대 100이다.
# 출력
# 첫째 줄에 입력으로 주어진 단어의 길이를 출력한다.
print(len(input()))


# 2744 번
# 문제
# 영어 소문자와 대문자로 이루어진 단어를 입력받은 뒤,
# 대문자는 소문자로, 소문자는 대문자로 바꾸어 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 영어 소문자와 대문자로만 이루어진 단어가 주어진다.
# 단어의 길이는 최대 100이다.
# 출력
# 첫째 줄에 입력으로 주어진 단어에서 대문자는 소문자로, 소문자는 대문자로 바꾼 단어를 출력한다.

# 풀이 1 - 글자마다 불러와서 전환
a = input()
b=""
for i in a:
    if i<"a":
        b+=i.lower()
    else:
        b+=i.upper()
print(b)

# 풀이 2 - swapcase 사용
print(input().swapcase())





""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """
""" ######################################## 아래는 수정 필요 ######################################## """

# 2086 번 - 메모리 초과
# 문제
# 제 1항과 제 2항을 1이라 하고, 제 3항부터는 앞의 두 항의 합을 취하는 수열을 피보나치(fibonacci) 수열이라고 한다.
# 예를 들어 제 3항은 2이며, 제 4항은 3이다.
# 피보나치 수열의 a번째 항부터 b번째 항까지의 합을 구하는 프로그램을 작성하시오.
# 수가 매우 커질 수 있으므로 마지막 아홉 자리만을 구하도록 한다.
# 즉 1,000,000,000으로 나눈 나머지를 구하면 된다.
# 입력
# 첫째 줄에 a와 b이 주어진다.
# 출력
# 첫째 줄에 구한 합을 출력한다.

fib = [0,1,1]
getdata = list(map(int,input().split()))
a = min(getdata)
b = max(getdata)
while True:
    try:
        fib[b]
        break
    except:
        fib.append(fib[-1]+fib[-2])
print(sum(fib[a:b+1])%10**9)





# 1934 번 - 통과는 했는데 시간 개선 필요
# 문제
# 두 자연수 A와 B에 대해서, A의 배수이면서 B의 배수인 자연수를 A와 B의 공배수라고 한다.
# 이런 공배수 중에서 가장 작은 수를 최소공배수라고 한다.
# 예를 들어, 6과 15의 공배수는 30, 60, 90등이 있으며, 최소 공배수는 30이다.
# 두 자연수 A와 B가 주어졌을 때, A와 B의 최소공배수를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다.
# 둘째 줄부터 T개의 줄에 걸쳐서 A와 B가 주어진다. (1 ≤ A, B ≤ 45,000)
# 출력
# 첫째 줄부터 T개의 줄에 A와 B의 최소공배수를 입력받은 순서대로 한 줄에 하나씩 출력한다.

# 풀이 1 - 시간 초과, 숫자 리스트를 받아서 1~작은수 로 나누기
for _ in range(int(input())):
    num = sorted(list(map(int,("1 "+input()).split()))) # 리스트 생성
    for i in range(num[1]):
        a=num[1]-i # 제수 = 작은수 ~ 1 사이의 수
        if a == 0: # 제수가 0 일 때 종료
            break
        elif num[1]%a == 0 and num[2]%a == 0: # 두 피제수에 대한 나머지가 0 일 때 값 업데이트
            num[1]/=a
            num[2]/=a
            num[0]*=a
    print(int(num[0]*num[1]*num[2]))

# 풀이 2 - 시간 초과, while을 하나 더 넣어서 값 업데이트 후 break 진행
for _ in range(int(input())):
    num = sorted(list(map(int,("1 "+input()).split()))) # 리스트 생성
    try:
        while True:
            for i in range(num[1]):
                a = num[1] - i  # 제수 = 작은수 ~ 1 사이의 수
                if a == 0:  # 제수가 0 일 때 종료
                    break
                elif num[1] % a == 0 and num[2] % a == 0:  # 두 피제수에 대한 나머지가 0 일 때 값 업데이트
                    num[1] /= a
                    num[2] /= a
                    num[0] *= a
                    break
    except TypeError:
        print(int(num[0]*num[1]*num[2]))

# 풀이 3 - 시간 초과, 역순 한게 문제인 것 같아서 다시 변경
for _ in range(int(input())):
    num = sorted(list(map(int,("1 "+input()).split()))) # 리스트 생성
    try:
        while True:
            x = num[0]
            for i in range(2, int(num[1])+1):
                if num[1] % i == 0 and num[2] % i == 0:  # 두 피제수에 대한 나머지가 0 일 때 값 업데이트
                    num[1] /= i
                    num[2] /= i
                    num[0] *= i
                    break
            if x == num[0]:
                x/0
    except:
        print(int(num[0]*num[1]*num[2]))

# 풀이 4 - 다른 문제에서...
def diviser(num):
    divs = []
    for i in range(1,num+1):
        if num%i==0:
            divs.append(i)
    return divs

for _ in range(int(input())):
    a, b = map(int,input().split())
    div = diviser(min([a,b]))
    max_div = max([x for x in div if max([a,b])%x==0])
    min_mul = int(a * b / max_div)
    print(min_mul)

# 풀이 5 - 라이브러리
from math import lcm
for _ in range(int(input())):
    a, b = map(int,input().split())
    print(lcm(a,b))




# 4948 번 - 시간 초과
# 문제
# 베르트랑 공준은 임의의 자연수 n에 대하여, n보다 크고, 2n보다 작거나 같은 소수는 적어도 하나 존재한다는 내용을 담고 있다.
# 이 명제는 조제프 베르트랑이 1845년에 추측했고, 파프누티 체비쇼프가 1850년에 증명했다.
# 예를 들어, 10보다 크고, 20보다 작거나 같은 소수는 4개가 있다. (11, 13, 17, 19)
# 또, 14보다 크고, 28보다 작거나 같은 소수는 3개가 있다. (17,19, 23)
# 자연수 n이 주어졌을 때, n보다 크고, 2n보다 작거나 같은 소수의 개수를 구하는 프로그램을 작성하시오.
# 입력
# 입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 케이스는 n을 포함하는 한 줄로 이루어져 있다.
# 입력의 마지막에는 0이 주어진다.
# 출력
# 각 테스트 케이스에 대해서, n보다 크고, 2n보다 작거나 같은 소수의 개수를 출력한다.
# 제한
# 1 ≤ n ≤ 123,456

# 풀이 1
def prime(n):
    if n == 1:
        return 0
    else:
        m = int(n**0.5+1)
        o = 1
        for i in range(2,m):
            if n % i == 0:
                o = 0
                break
        return o

while True:
    n=int(input())
    c=0
    if n==0:break
    if n==1:
        print(1)
        continue
    else:
        # 수정 전: number 의 원소가 범위 내의 모든 수
        # numbers = [i for i in range(n+1, 2*n+1)]
        # 수정 후: numbers 의 원소를 범위 내의 홀수로 제한
        numbers = [2 * i + 1 for i in range(int((n + 1) / 2), n)]
        # 수정 전: map 사용하여 list 생성
        # Prime = list(map(prime,numbers))
        # 수정 후: for 사용하여 list 생성
        Prime = []
        for i in numbers:
            Prime.append(prime(i))
    print(Prime.count(1))

# 2617 번
# 문제
# 모양은 같으나, 무게가 모두 다른 N개의 구슬이 있다. N은 홀수이며, 구슬에는 번호가 1,2,...,N으로 붙어 있다.
# 이 구슬 중에서 무게가 전체의 중간인 (무게 순서로 (N+1)/2번째) 구슬을 찾기 위해서 아래와 같은 일을 하려 한다.
# 우리에게 주어진 것은 양팔 저울이다. 한 쌍의 구슬을 골라서 양팔 저울의 양쪽에 하나씩 올려 보면 어느 쪽이 무거운가를 알 수 있다.
# 이렇게 M개의 쌍을 골라서 각각 양팔 저울에 올려서 어느 것이 무거운가를 모두 알아냈다.
# 이 결과를 이용하여 무게가 중간이 될 가능성이 전혀 없는 구슬들은 먼저 제외한다.
# 예를 들어, N=5이고, M=4 쌍의 구슬에 대해서 어느 쪽이 무거운가를 알아낸 결과가 아래에 있다.
# 구슬 2번이 구슬 1번보다 무겁다.
# 구슬 4번이 구슬 3번보다 무겁다.
# 구슬 5번이 구슬 1번보다 무겁다.
# 구슬 4번이 구슬 2번보다 무겁다.
# 위와 같이 네 개의 결과만을 알고 있으면, 무게가 중간인 구슬을 정확하게 찾을 수는 없지만,
# 1번 구슬과 4번 구슬은 무게가 중간인 구슬이 절대 될 수 없다는 것은 확실히 알 수 있다.
# 1번 구슬보다 무거운 것이 2, 4, 5번 구슬이고, 4번 보다 가벼운 것이 1, 2, 3번이다. 따라서 답은 2개이다.
# M 개의 쌍에 대한 결과를 보고 무게가 중간인 구슬이 될 수 없는 구슬의 개수를 구하는 프로그램을 작성하시오.
# 입력
# 첫 줄은 구슬의 개수를 나타내는 정수 N(1 ≤ N ≤ 99)과 저울에 올려 본 쌍의 개수 M(1 ≤ M ≤ N(N-1)/2)이 주어진다.
# 그 다음 M 개의 줄은 각 줄마다 두 개의 구슬 번호가 주어지는데, 앞 번호의 구슬이 뒤 번호의 구슬보다 무겁다는 것을 뜻한다.
# 출력
# 첫 줄에 무게가 중간이 절대로 될 수 없는 구슬의 수를 출력 한다.

N, M = map(int,input().split())
weight = [[0,0]] * N
for _ in range(M):
    a, b = map(int,input().split())
    i1 = weight[a-1][0] + 1
    i2 = weight[a-1][1]
    j1 = weight[b-1][0]
    j2 = weight[b-1][1] + 1
    weight[a-1] = [i1, i2]
    weight[b-1] = [j1, j2]
    print(f"[{i1}, {i2}], [{j1}, {j2}]")
    print(weight)
print(weight)


# 1759 번 - ?
# 문제
# 바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은,
# 702호에 새로운 보안 시스템을 설치하기로 하였다.
# 이 보안 시스템은 열쇠가 아닌 암호로 동작하게 되어 있는 시스템이다.
# 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며
# 최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다.
# 또한 정렬된 문자열을 선호하는 조교들의 성향으로 미루어 보아
# 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측된다.
# 즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다.
# 새 보안 시스템에서 조교들이 암호로 사용했을 법한 문자의 종류는 C가지가 있다고 한다.
# 이 알파벳을 입수한 민식, 영식 형제는 조교들의 방에 침투하기 위해 암호를 추측해 보려고 한다.
# C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 두 정수 L, C가 주어진다. (3 ≤ L ≤ C ≤ 15)
# 다음 줄에는 C개의 문자들이 공백으로 구분되어 주어진다.
# 주어지는 문자들은 알파벳 소문자이며, 중복되는 것은 없다.
# 출력
# 각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력한다.

L, C = map(int,input().split())
password = set(map(str,input().split()))
vowel = {"a", "e", "i", "o", "u"}
v_in_p = password.intersection(vowel)


# 25192 번 - 시간 초과
# 문제
# 알고리즘 입문방 오픈 채팅방에서는 새로운 분들이 입장을 할 때마다 곰곰티콘을 사용해 인사를 한다. 이를 본 문자열 킬러 임스는 채팅방의 기록을 수집해 그 중 곰곰티콘이 사용된 횟수를 구해 보기로 했다.
# ENTER는 새로운 사람이 채팅방에 입장했음을 나타낸다. 그 외는 채팅을 입력한 유저의 닉네임을 나타낸다. 닉네임은 숫자 또는 영문 대소문자로 구성되어 있다.
# 새로운 사람이 입장한 이후 처음 채팅을 입력하는 사람은 반드시 곰곰티콘으로 인사를 한다. 그 외의 기록은 곰곰티콘을 쓰지 않은 평범한 채팅 기록이다.
# 채팅 기록 중 곰곰티콘이 사용된 횟수를 구해보자!
# 입력
# 첫 번째 줄에는 채팅방의 기록 수를 나타내는 정수 N 이 주어진다. (1 <= N <= 100,000)
# 두 번째 줄부터 N 개의 줄에 걸쳐 새로운 사람의 입장을 나타내는 ENTER, 혹은 채팅을 입력한 유저의 닉네임이 문자열로 주어진다. (1 <= 문자열 길이 <= 20)
# 첫 번째 주어지는 문자열은 무조건 ENTER이다.
# 출력
# 채팅 기록 중 곰곰티콘이 사용된 횟수를 출력하시오.

# 풀이 1
count = 0 # 횟수 체크 변수 선언
for _ in range(int(input())):
    log = input()
    if log == "ENTER": # 채팅 로그가 "입장"이면 채팅 로그 리스트 초기화
        gomgom = []
    elif log not in gomgom: # 채팅 로그 리스트 내에 닉네임이 없을 경우 닉네임 삽입하고, 곰곰티콘 횟수 1회 증가
        gomgom.append(log)
        count += 1
print(count)


# 11653 번 - 시간 초과
# 문제
# 정수 N이 주어졌을 때, 소인수분해하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 정수 N (1 ≤ N ≤ 10,000,000)이 주어진다.
# 출력
# N의 소인수분해 결과를 한 줄에 하나씩 오름차순으로 출력한다. N이 1인 경우 아무것도 출력하지 않는다.

# 풀이 1 - 소수를 먼저 입력해 놓고 나누기, 시간 초과
primenumber = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,
               101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,
               211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293,
               307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397,
               401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499,
               503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599,
               601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691,
               701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797,
               809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887,
               907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997]
N = int(input())
while N>1:
    for i in primenumber:
        if N % i == 0:
            print(i)
            N /= i
            break

# 풀이 2 - N 이하의 소수를 구하고 소인수분해 하기, 시간 초과
def prime(n):
    if n == 1:
        return 0
    else:
        m = int(n**0.5+1)
        for i in range(2,m):
            if n % i == 0:
                n = 0
                break
        return n

N = int(input())
N_list = [i for i in range(N+1)]
M_list = list(set(map(prime,N_list)))
M_list.sort()
if 0 in M_list:
    M_list.remove(0)
while N>1:
    for i in M_list:
        if N % i == 0:
            print(i)
            N /= i
            break
        else:
            M_list.remove(i)

















# 10815 번 - 시간 초과
# 문제
# 숫자 카드는 정수 하나가 적혀져 있는 카드이다. 상근이는 숫자 카드 N개를 가지고 있다. 정수 M개가 주어졌을 때, 이 수가 적혀있는 숫자 카드를 상근이가 가지고 있는지 아닌지를 구하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 상근이가 가지고 있는 숫자 카드의 개수 N(1 ≤ N ≤ 500,000)이 주어진다. 둘째 줄에는 숫자 카드에 적혀있는 정수가 주어진다.
# 숫자 카드에 적혀있는 수는 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다. 두 숫자 카드에 같은 수가 적혀있는 경우는 없다.
# 셋째 줄에는 M(1 ≤ M ≤ 500,000)이 주어진다.
# 넷째 줄에는 상근이가 가지고 있는 숫자 카드인지 아닌지를 구해야 할 M개의 정수가 주어지며, 이 수는 공백으로 구분되어져 있다.
# 이 수도 -10,000,000보다 크거나 같고, 10,000,000보다 작거나 같다
# 출력
# 첫째 줄에 입력으로 주어진 M개의 수에 대해서, 각 수가 적힌 숫자 카드를 상근이가 가지고 있으면 1을, 아니면 0을 공백으로 구분해 출력한다.

# 시간 초과
from sys import stdin
N = int(stdin.readline())
N_list=list(map(int,stdin.readline().split()))
M = int(stdin.readline())
M_list=list(map(int,stdin.readline().split()))
C_list=[]
for i in M_list:
    if i in N_list:
        C_list.append(1)
    else:
        C_list.append(0)
print(C_list)

# 런타임 에러, 외부 lib 없음
from sys import stdin
import pandas as pd
N = int(stdin.readline())
N_df=pd.DataFrame(map(int,stdin.readline().split()),columns=["N"])
M = int(stdin.readline())
M_df=pd.DataFrame(map(int,stdin.readline().split()),columns=["M"])
Filter = M_df["M"].isin(N_df["N"])
M_df.loc[Filter, "M"] = 1
M_df.loc[-Filter, "M"] = 0
print(" ".join(list(M_df["M"])))


# 2004 번 - 시간 초과
# 문제
# binom{n}{m}의 끝자리 $0$의 개수를 출력하는 프로그램을 작성하시오
# 입력
# 첫째 줄에 정수 n, m (0 ≤ m ≤ n ≤ 2,000,000,000, n != 0 )이 들어온다.
# 출력
# 첫째 줄에 binom{n}{m}의 끝자리 0의 개수를 출력한다.

# 시간 초과
from math import factorial
n, m = map(int,input().split())
n_m = int(factorial(n)//(factorial(m)*factorial(n-m)))
count = 0
while n_m%10==0:
    n_m//=10
    count+=1
print(count)

# 시간 초과
from math import factorial
n, m = map(int,input().split())
n_m = list(str(int(factorial(n)//(factorial(m)*factorial(n-m)))))
n_m.reverse()
count = 0
for i in n_m:
    if i=="0":
        count+=1
    else:
        break
print(count)

# 시간 초과
from sys import stdin
from math import factorial
n, m = map(int,stdin.readline().split())
n_m = list(str(int(factorial(n)//(factorial(m)*factorial(n-m)))))
n_m.reverse()
count = 0
for i in n_m:
    if i=="0":
        count+=1
    else:
        break
print(count)

# 시간 초과
from math import factorial
n, m = map(int,input().split())
n_m = list(str(int(factorial(n)//(factorial(m)*factorial(n-m)))))
n_m.reverse()
count = len(n_m)
for i in range(1,10):
    count=min(0, n_m.index(i))
print(count)


# 10757 번 - C 언어 문제
# 문제
# 두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.
# 입력
# 첫째 줄에 A와 B가 주어진다. (0 < A,B < 10**10000)
# 출력
# 첫째 줄에 A+B를 출력한다.
import sys
a,b=map(int,sys.stdin.readline().split())
print(a+b)



"""
# 풀이 1 - 시간 초과
def fibonacci(n, listing):
    if n == 0:
        listing.append(n)
        return 0, listing
    elif n == 1:
        listing.append(n)
        return 1, listing
    else:
        return fibonacci(n-1, listing) + fibonacci(n-2, listing)

for i in range(int(input())):
    count = []
    fibonacci(int(input()),count)
    print(count.count(0), count.count(1))

# 풀이 2
def fibonacci(n):
    if n == 0:
        f_list.append(0)
        return 0
    elif n == 1:
        f_list.append(1)
        return 1
    else:
        return fibonacci(n-1) + fibonacci(n-2)
global f_list
f_list = []
fibonacci(6)
print(f_list)
"""




"""
시간 측정 모델
from time import time
start = time()



print("#######end#######")
print(time()-start)
"""

"""
파이참 편집 기능
# 찾아서 바꾸기
편집할 부분을 블럭으로 씌운 다음에 Ctrl + R 로 특정 문자를 바꿈

# 위 아래 코드와 줄바꿈
해당 열에 커서를 놓고 Alt + Shift + 방향키

# 동일 위치 열 편집
Ctrl + Ctrl + 방향키

# 다중 커서 편집
Alt + 클릭
"""